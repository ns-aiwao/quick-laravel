＠＠＠登社長（と大剛さん）に感謝して頑張ろう＠＠＠

/*** メモ ***/
★サーバが500エラー
原因：
「\storage\logs」内にあるエラーログを確認してみると、キーの指定がされていないとのこと

対処法：
## .envファイル作成
copy .env.example .env
encryption keyを作成します。

## APP_KEYの作成
php artisan key:generate

## キャッシュクリア
php artisan cache:clear
再度起動します。

※.envはGit管理されないみたい。（確かに環境設定だからな。。。）
  それぞれローカルに作成、設定する。（なるほど）

★エラーWarning: require /public/../vendor/autoload.php): failed to open 
stream: No such file or directory in 
projects/laravel/github-laravel/public/index.phpの対処法

原因：
/vendor/autoload.phpというファイルがないことが問題。
これは、初期状態ではバンドルがインストールされておらず、autoloadも入っていないため。
必要なバンドルが記された、composer.jsonはあるが、実際にインストール済みのバンドルが列挙してあるcomposer.lockが存在していない。

対処法：
composerを使ってバンドルをインストールする。
$ composer update

/********************************/

##### 速習Laravel6 （山田先生）##############################################
!!! Laravel 8からは次のようにしないとダメ !!!
その１　完全修飾名でコントローラーを指定
Route:get('hello', 'App\Http\Controllers\HelloController@index');
その２  useでコントローラをインポートする
use App\Http\Controllers\HelloController;
Route::get('/hello', [HelloController::class, 'index']);


1.HTMLベースのテンプレートエンジン（Blade）
2.データベースアクセスのための基本機能＆O/Rマッピング
3.リクエスト共通の処理を管理するミドルウェア
4.入力値の検証機能（Validation）
5.URLに応じてページを振り分けるルーティング機能
6.サービス間の依存関係を解決するDIコンテナ
7.単体テスト／ブラウザテストを支援するテスティングフレームワーク
8.認証／キャッシュ／タスクスケジューリング／ページングなどの支援機能

＠Laravelで利用できる主なライブラリ／ツール
Laravel Collective  HTML生成などのヘルパー群
Laravel Socialite  OAuthによるSNS連携
Laravel Scout  全文検索機能のためのライブラリ
Intervention Image  画像処理のためのライブラリ
Laravel Telescope  デバッグアシスタント

＠Composerのインストール
Composerは、PHPの拡張ライブラリ（パッケージ）をインストールするためのパッケー
ジ管理ツール。

＠新規のアプリを作成する
>cd c:\data
>laravel new quick-laravel
...
----------------------------------
＊composerからのインストール
Composerから直接Laravelアプリを生成することもできる。
>composer create-project laravel/laravel quick-laravel --prefer-dist
--prefer-distは、GitHunなどからzip形式でライブラリを取得しろ、という意味。
==================================

＠アプリの構造を確認する
laravel newコマンドを実行した直後のフォルダ／ファイル構造：
/quick-laravel          アプリルート
  /app                  アプリケーション本体のコード
    /Console            コンソールアプリ関連
    /Exceptions         例外処理関連
    /Http               Webアプリ関連
    /Providers          プロバイダー関連
  /bootstrap            アプリ起動時に実行されるコード
  /config               アプリ共通の設定
  /database             データベース関連のファイル群
  /public               公開フォルダ（JavaScript/CSSなど）
  /resources            アプリで利用するリソース
  /routes               ルーティング関連の定義
  /storage              アプリが操作するファイルの保存先
  /tests                テストコード
  /vendor               Laravel本体はじめライブラリコード
  artisan               Laravelで利用できるコマンド
  composer.json         composerの設定ファイル
  package.json          npm（Node.js）の設定ファイル
  phpunit.xml           PHPUnit（テストツール）の設定ファイル
  server.php            サーバ起動時に実行すべきコード
==================================

＠アプリを実行する
Laravelには開発用のサーバ機能が標準で内蔵されている。
----------------------------------
>cd quick-laravel
>php artisan serve
...
----------------------------------

＠Apacheサーバで実行する
本番環境では、ApacheやNginxのような環境を準備すべき。
----------------------------------
[1]アプリを配置する
用意したアプリをApacheの公開フォルダ/htdocsに配置する。
これだけで以下のアドレスからアプリを実行できるようになる。
http://localhost/quick-laravel/public
----------------------------------
[2]アドレスを振り分ける
上記のようなアドレスは冗長であり、公開するには望ましくない。
そこで、Apacheの設定を変更して「http://localhost」として呼び出すようにしてみる
。
httpd.confからドキュメントルートを編集する。
----------------------------------
[httpd.conf]
DocumentRoot "c:/xampp/htdocs/quick-laravel/public"
<Directory "c:/xampp/htdocs/quick-laravel/public">
...
==================================

Part3 Laravelの基本

＠コントローラーの基本
Laravelアプリにおいて、処理の起点となるのはコントローラクラス。
コントローラは、Model-View-ControllerのControllerに相当する部分。
個々のリクエストを受取り、ビジネスロジック（Model）を呼出し、その結果をビュー
（View）に反映させる、処理の司令塔。

＠コントローラーを作成する
コントローラークラスを作成するには、以下のコマンドを実行する。
以下は、HelloControllerというコントローラーを作成する例。
----------------------------------
>php artisan make:controller HelloController
...
----------------------------------
コントローラーの名前は任意に決められるが、一般には、XxxxControllerのように、Co
ntrollerを接尾辞に付ける。
成功したら、/app/Http/Controllersフォルダ配下にHelloController.phpが生成されて
いる。
==================================

＠コントローラークラスを編集する
自動生成されたコードに対して、最低限のコードを追加してみる。
----------------------------------
[HelloController.php]
<?php
namespace App\Http\Controllers;

use Illuminate\Http\Request;

//a. Controllerクラスを継承
class HelloController extends Controller
{
  //b. アクションメソッドを定義
  public function index()
  {
    //c. 出力を戻り値に
    return 'こんにちは、世界！';
  }
}
----------------------------------
a.Controllerクラスを継承する
Controllerクラス（App\Http\Controllers名前空間）は、コントローラーとしての基本
的な機能を提供する。
自動生成されたコードをそのまま利用する分にはあまり意識する必要はないが、まずは
コントローラークラスはControllerクラスを継承すると覚えること。
----------------------------------
b.リクエストを処理するのはアクションメソッドの役割
クライアントからのリクエストを処理するのは、コントローラークラスで定義されたpu
blicメソッド。
これをアクションメソッドという。
逆に言えば、一つ以上のアクションメソッドを束ねたクラスが、コントローラークラス
ということ。
この例では、ひとつのindexアクション（メソッド）を定義しているだけだが、必要に
応じて複数のアクションを列記することも可能。
----------------------------------
c.アクションメソッドの戻り値が出力ん
アクションメソッドには、リクエストを受けて、モデル（ビジネスロジック）を呼び出
したり、ビュー（画面）生成のための準備など、役割がある。
が、ここでは、最もシンプルに文字列を出力するだけのコードを記述している。
アクションメソッドでは、戻り値として文字列を返すことで、これがそのままクライア
ント（ブラウザ）への出力となる。
==================================

＠ルーティング情報を定義する
ルーティングとは、リクエストURLに応じて処理の受け渡し先を決定すること、または
そのしくみのことをいう。
Laravelでは、クライアントからの要求を受け取るは、まずはルーティング機能を利用
して呼び出すべきコントローラー（アクション）を決定する。
ルーティング機能を提供するライブラリのことをルータともいう。
----------------------------------
ルーティング設定（ルート）は、/routes/web.phpに定義する。
既定で「/」にたいするルートが用意されているので、その後方に新たなルートを追加
する。
「/」ルートはトップページを表示するためのものなので削除してはいけない。
----------------------------------
[web.php]
//「/」に対するルート
Route::get('/', function() { ... });
//「/hello」に対するルート
Route:get('hello', 'HelloController@index');
----------------------------------
ルートを定義するにはいくつかの方法があるが、Route::getは最もシンプルなメソッド
Route::get(path, action)
・path：リクエストパス
・action：実行すべきアクション
actionには、呼び出すべきアクションを「コントローラー名@アクション名」の形式で
指定する。
これにより「～/hello」で、HelloController@indexアクションを呼び出せ、という意
味になる。
一般的なアプリケーションでは、ページの数だけルートを定義することになる。
----------------------------------
＊ルートから出力を生成する
まずはリクエストの振り分けはルーター（web.php）、実処理はコントローラー（XxxxC
ontroller.php）という役割分担が基本だが、簡易的にルート上で出力を生成しても構
わない。
例えば、web.phpに以下のように書いても同じ。
Route:get('hello', function() {
  return 'こんにちは、世界！'
});
----------------------------------
!!! Laravel 8からは次のようにしないとダメ !!!
その１　完全修飾名でコントローラーを指定
Route:get('hello', 'App\Http\Controllers\HelloController@index');
その２  useでコントローラをインポートする
use App\Http\Controllers\HelloController;
Route:get('hello', [HelloController::class, 'index']);
==================================

＠ビューの基本
Model-View-Controllerの考え方からすると、最終的な出力にはBladeテンプレートを利
用するのが基本。
Bladeテンプレートは、HTMLにPHPを埋め込むための仕組み。
HTMLがベースとなるため、最終的な出力をイメージしながら、レイアウトを進められる
というメリットがある。
----------------------------------
[1]アクションを追加する
HelloControllerにviewメソッド（アクション）を追加する。
----------------------------------
class HelloController extends Controller
{
  ...
  public function view()
  {
    //a. ビュー変数を準備
    $data = [
      'msg' => 'こんにちは、世界！'
    ];
    //b. テンプレートを呼び出す
    return view('hello.view', $data);
  }
}
----------------------------------
a.ビュー変数を準備する
ビュー変数とは、テンプレートに埋め込む値のこと。
Bladeを利用する場合、アクション側で表示に必要なデータを用意しておき、テンプレ
ートではデータを埋め込む場所や表示方法などを定義する、という役割分担が基本。
ビュー変数は、「名前=>値」形式の連想配列として準備する。
複数のビュー変数を用意することもできるし、値にも文字列だけでなく、数値／配列な
ど任意のオブジェクトを指定できる。
----------------------------------
b.テンプレートの呼出し
テンプレートを呼び出すのはviewメソッドの役割。
view(path, args)
・path：テンプレートのパス
・args：ビュー変数
pathには「フォルダ名.ファイル名」の形式で、呼び出すテンプレートを指定する。
・区切り文字は「.」である点
・ファイル名はベース名（拡張子なし）で表す点
に注目。
この例では、「hello.view」なので、/hello/view.blade.phpというテンプレートを探
しに行く。
----------------------------------
[2]テンプレートを準備する
テンプレートファイルは/resoucrs/viewsフォルダ配下に「コントローラー名/アクショ
ン名.blade.php」として配置するのが一般的。
そのようにすることで、コントローラーとアクションの対応関係が明らかになるからで
ある。
コントローラ名は、接尾辞のControllerを除いて表す。
この例であれば、HelloController@viewアクションに対応するテンプレートなので、/h
ello/view.blade.phpとなる。
----------------------------------
[hello/view.blade.php]
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>速習Laravel</title>
</head>
<body>
{{ $msg }}
</body>
</html>
----------------------------------
アクション側で準備したビュー変数を参照するには{{...}}を利用する。
ビュー変数は「$msg」のように$付きで表す。
ビュー変数をただ埋め込むだけでなく、値を返す式であれば、任意の関数／メソッドも
利用できる。
例：
現在の日時：{{ date('Y年m月d日 h:i:s') }}
----------------------------------
[3]サンプルを実行する
準備ができたら、web.phpにルート定義をを追加する。
use App\Http\Controllers\HelloController;
...
Route::get('hello/view', [HelloController::class, 'view']);
----------------------------------
>cd quick-laravel
>php artisan serve
で内蔵サーバを立ち上げ、
http://127.0.0.1:8000/hello/view
で実行される。
==================================

＠モデルの基本
Model（モデル）とは、データベース／外部サービスへのアクセスをはじめ、ビジネス
ロジックを担うコンポーネントのこと。
アプリの心臓部である。
Laravelでは、データベースへのアクセス手段として、いくつかのアプローチを提供し
ているが、ここではLaravel標準のO/RマッパーであるEloquentを採る。

＠Eloquentとは
Eloquentとは、データベース（リレーショナル形式のデータ）とアプリのモデルクラス
（オブジェクト）形式のデータを受け渡す（Object/Relational）マッパーの一種。
O/Rマッパーを利用することで、一つのテーブルを一つのモデルクラスに、一つのフィ
ールドを1つのプロパティに割り当てられるので、データベースから取得した結果をオ
ブジェクトに詰め替えるような手間が不要になる。
逆も然り。
オブジェクト操作の一環として、データベースを操作できるようになる。

＠データベースの準備
>mysql -u root -p(パスワード）
Enter:..
>CREATE DATABASE quick_laravel CHARACTER SET utf8;
Query OK,...
...
>GRANT ALL PRIVILIGES ON quick_laravel.* TO quickusr@localhost
IDENTIFIED BY 'quickpass';
Query OK,...
>USE quick_laravel;
Database changed
>source c:\quick.sql
....
Query OK, ...
>\q
Bye
==================================

＠データベース接続定義ファイルを編集する
Laravelからデータベースに接続するには、/configフォルダ配下の設定ファイルdataba
se.phpを編集する。
----------------------------------
[database.php]
<?php
use Illuminate\Support\Str;
return {
  //c.既定の接続
  'default' => env('DB_CONNECTION', 'mysql'),
  //a.データベースごとの設定
  'connections' => [
    'sqlite' => [...],
    //b. MySQL(MariaDB)の設定
    'mysql' => [
      'driver' => 'mysql',
      'url' => env('DATABASE_URL'),
      'host' => env('DB_HOST', '127.0.0.1'),
      'port' => env('DB_PORT', '3306'),
      'database' => env('DB_DATABASE', 'quick_laravel'),
      'username' => env('DB_USERNAME', 'quickusr'),
      'password' => env('DB_PASSWORD', 'quickpass'),
      'unix_socket' => env('DB_SOCKET', ''),
      'charset' => 'utf8mb4',
      'collation' => 'utf8mb4_unicode_ci',
      ...
    ],
    'pgsql' => [...],
    'sqlsrv' => [...],
  ],
];
----------------------------------
connectionsキーの配下にデータベースごとの設定がまとめられている。
----------------------------------

＠Laravel環境変数を定義する。
アプリルートの直下に.envという環境変数ファイルが用意されているので、データベー
スの情報などを定義する。
----------------------------------
[.env]
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=quick_laravel
DB_USERNAME=quickusr
DB_PASSWORD=quickpass
----------------------------------
＊env関数の意味
「env('DB_HOST', '127.0.0.1')」は、環境変数DB_HOSTから値を取得し、存在しない場
合は既定値として127.0.0.1を採用する、という意味。
環境変数として.envに切り分けているのは、開発環境と本番環境との設定情報の差し替
えを簡単にするため。
本番環境に移行する際には、本番環境の.envを用意して、.envだけを差し替えるのが基
本。
==================================

＠モデルクラスの作成
モデルクラスの作成には、コントローラークラスの作成にも利用したphp artisanコマ
ンドを利用する。
----------------------------------
>php artisan make:model Book
Model created successfully.
----------------------------------
モデルクラスは、テーブル名（複数形のbooks）に対して、単数形（Book）にする。
これによってモデルとテーブルが紐づく。
----------------------------------
[Book.php]
<?php
namespace App;
use Illuminate\Database\Eloquent\Model;
//Modelクラスを継承
class Book extends Model
{
  //
}
----------------------------------
作成されたモデルクラスは、Modelクラス（Illuminate\Database\Eloquent\Model名前
空間）を継承しただけの空のクラスだが、現時点では今のままで構わない。
Laravelが紐づいたテーブルから列情報を暗黙的に取得してくれるから。
==================================

＠データアクセスの基本
[1]アクションメソッドを追加する
HelloControllerに対して、新たなアクションとしてlistメソッドを追加する。
----------------------------------
[HelloController.php]
use App/Book;
class HelloController extends Controller
{
  ...
  public function list() 
  {
    // booksテーブルから全業を取得
    $data = [
      'records' => Book::all()
    ];
    return view('hello.list', $data);
  }
}
----------------------------------
すべてのレコードを無条件に取得するには、作成済みのBookモデルからallメソッドを
呼び出す。
all()は、「SELECT * FROM books」と同じ意味で、結果をCollectionオブジェクトとし
て返す。
これを、テンプレート側から参照できるようにビュー変数に格納しておく。
----------------------------------
[2]テンプレートファイルを作成する
HelloController@listアクションに対するテンプレートファイルhello/list.blade.php
を作成する。
----------------------------------
[hello/list.blade.php]
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>速習Laravel</title>
<link rel="stylesheet"
href="https://stackpath.bootstrapcdn.com/bootstrap4.3.1/css/bootstrap.min.css">
</head>
<body>
<table class="table">
<tr>
<th>書名</th>
<th>価格</th>
<th>出版社</th>
<th>刊行日</th>
</tr>
@foreach ($records as $record)
<tr>
<td>{{ $record->title }}</td>
<td>{{ $record->price }}</td>
<td>{{ $record->publisher }}</td>
<td>{{ $record->published }}</td>
</tr>
@endforeach
</table>
</body>
</html>
----------------------------------
Collectionのような配列ライクなオブジェクトを順に処理するのは、@foreachディレク
ティブの役割。
ディレクティブとは、いわゆるBladeテンプレートの中で利用できる命令のこと。
条件分岐、ループ、その他の基本的な制御構文が用意されており、@...の形式で表すの
が基本。
----------------------------------
@foreachディレクティブ
@foreach (list as var)
  ...
@endforeach
・list  繰り返し対象の配列
・var  仮引数
==================================

Part 4：ビュー開発

＠HTMLエスケープの無効化  {!!...!!}
HTMLエスケープとは、HTMLの予約語である<, >, &などを、&lt;, &gt;, &amp;のような
無害な文字列に置き換えること。
外部から取得した値を出力するうえで、適切なエスケープ処理は欠かせない。
XSSの脆弱性につながるから。
----------------------------------
が、Laravelを利用するうえで、エスケープを意識することはほとんどない。
{{...}}式では、式の値を暗黙的にエスケープして出力するから。
が、時として、動的にHTMLを生成し、ページに反映させたいというケースもある。
そのような場合、{!!...!!}}を代わりに使用する。
----------------------------------
[ViewController.php]
public function escape()
{
  return view('view.escape', [
    'msg'=>'<img src="https://wings.msn.to/image/wings.jpg" title="ロゴ">
    <p>WINGSへようこそ</p>
  ]);
}
[view/escape.blade.php]
{!! $msg !!}
}
----------------------------------
これで$msgに含まれるタグがタグとして解釈される。
----------------------------------
＊{!!...!!}は信頼できるコンテンツだけに利用する
{!!...!!}は、信頼できる（＝適切なエスケープ処理が行われていることがわかってい
る）コンテンツに対してのみ利用すべき。
==================================

＠{{...}}の無効化  @構文／@verbatim
{{...}}をPHPの式ではなく、そのまま文字列として表示したい場合には、{{...}}の前
に@を付与する。
<p>@{{ $msg }}</p>
----------------------------------
無効化したい{{...}}が複数ある場合は、@verbatim～@endverbatimで該当のコードを括
ることもできる。
@verbatim
<p>{{ $msg }}</p>
@endverbatim
==================================

＠テンプレートにコメントを残す  コメント構文
Bladeテンプレートの基盤はHTMLなので、まず<!-- ... -->は利用できる。
ただし、ブラウザ画面から見えないだけで、クライアントには表示される。
----------------------------------
クライアントに表示されないコメントを残すには、Bladeのコメント構文{{--...--}}を
利用する。
----------------------------------
[view/comment.blade.php]
{{--
これはこめんとです。
クライアントには送信されません。
--}}
==================================

＠ビューのディレクティブ
ディレクティブとは、@～で始まる特別な命令のこと。
何等かの指示をLaravelに渡すための仕組み。
==================================

＠汎用的な条件分岐を表す @if
@if...@endifディレクティブは、条件に応じて出力を決める。
----------------------------------
[ViewController.php]
public function if()
{
  return view('view.if', [
    'random' => random_int(0, 100)
  ]);
}
[view/if.blade.php]
@if ($random < 50)
<p>{{ $random }}は50未満です。</p>
@else
<p>{{ $random }}は50以上です。</p>
@endif
----------------------------------
@else、@elseifディレクティブも使用できる。
==================================

＠否定の条件分岐を表現する  @unless
trueの場合に配下のコンテンツを出力する@ifに対し、falseの場合に出力する@unless
も用意されている。
----------------------------------
[view/unless.blade.php]
@unless ($random === 50)
<p>{{ $random }}は50ではありません。</p>
@endunless
----------------------------------
@unlessでも、@else句は利用できるが、否定の否定は読みにくくなるので、普通に@if
を用いること。
==================================

＠変数の有無によって表示を振り分ける @isset/@empty
@ifの特殊な形態として、変数の有無、また、nullで内容かどうかによって表示を振り
分ける@isset、@emptyディレクティブもある。
----------------------------------
[ViewController.php]
public function isset()
{
  return view('view.isset', [
    'msg' => 'こんにちは、世界！',
  ]);
}
[view/isset.blade.php]
@isset($msg)
<p>変数msgは「{{ $msg }}」です。</p>
@endisset
----------------------------------
変数が存在しない場合にだけメッセージを表示したいならば、@emptyを利用する。
----------------------------------
[view/isset.blade.php]
@empty($msg)
<p>メッセージがありません</p>
@endempty
----------------------------------
@isset/@empty共に、@else句を持つことも可能である。
@isset($msg)
<p>変数msgは「{{ $msg }}」です。</p>
@else
<p>メッセージがありません！</p>
@endisset
==================================

＠等価比較による条件分岐を表現する @switch
式の値に応じて表示を振り分けるなら、@switchディレクティブを利用する。
----------------------------------
[ViewController.php]
public function switch()
{
  return view('view.switch', [
    'random' => random_int(1, 5)
  ]);
}
[view/switch.blade.php]
@switch($random)
  @case(5)
  <p>大ラッキーの一日です！</p>
    @break
  @case(4)
  <p>ちょっぴり良いことがあるかも？</p>
    @break
  @case(3)
  <p>ふつーの一日です。</p>
    @break
  @case(2)
  <p>今日は静かに過ごしましょう…</p>
    @break
  @default
  <p>umm…</p>
@endswitch
----------------------------------
構文そのものは、PHP標準のswitch命令と同じ。
==================================

＠条件式によって出力を繰り返す  @while
@whileディレクティブは、条件式がtrueの間だけループを繰り返す。
ディレクティブとしてはあまり利用する機会は無い
というんは、条件終了を満たすには、ループ内の処理が前提（何等かのコードが必要）
となるし、大概の用とは@foreach/@forでまかなえるから。
----------------------------------
[view/while.blade.php]
<!-- 変数の初期化 -->
@php
$i = 0;
@endphp
@while($i<6)
  @php
  $i++;
  @endphp
  <h{{ $i }}>{{ $i }}番目です。</h{{ $i }}>
@endwhile
----------------------------------
@php～@endphpは、いわゆる<?php～?>と同じ。
==================================

＠指定した回数だけ処理を繰り返す  @for
@forは、PHP標準のfor命令に相当する。
----------------------------------
[view/for.blade.php]
@for($i=1;$i<=6;$i++)
<h{{ $i }}>{{ $i }}番目です。</h{{ $i }}>
@endfor
----------------------------------
カウンター変数に基づいてループを制御するのであれば、@whileよりシンプルに@phpを
使わずに表現できる。
==================================

＠配列の内容を順番に出力する  @foreach
＊インデクス番号を取り出す
構文はPHP標準のforeach命令に順ずるので、インデクス番号／値の双方を仮引数として
受け取ることもできる。
----------------------------------
[hello/list.blade.php]
<table class="table">
<tr>
<th>No</th>
...
</tr>
@foreach($records as $id=>$record)
<tr>
  <td>{{ $id + 1}}</td>
  ...
</tr>
@endforeach
----------------------------------
＊連想配列を処理する
@foreachでは、連想配列も処理できる。
----------------------------------
[ViewController.php]
public function foreach_assoc()
{
  return view('view.foreach_asoc', [
    'member' => [
      'name' => 'YAMADA, Yoshihiro',
      'sex' => '男',
      'birth' => '1923-11-10'
    ]
  ]);
}
[view/foreach_assoc.blade.php]
@foreach ($members as $key=>$value)
<li>{{ $key }} : {{ $value }}</li>
@endforeach
----------------------------------
＊ループ変数を参照する
ループのは以下では、$loopという特殊な変数にアクセスできる。
$loopは、ループ変数とも呼ばれ、ループに関する様々な情報を持っている。
・index  インデクス番号（0スタート）
・iteration  繰り返し数（1スタート）
・remaininig  残っている要素数
・count  配列の総数
・first  最初の項目か
・last   最後の項目か
・even  偶数回目か
・odd  奇数回目か
・depth  入れ子レベル
・parent  親のループ変数（ネストした入れ子の場合）
----------------------------------
[ViewController.php]
public function foreach_loop()
{
  return view('view.foreach_loop', [
    'weeks' => ['月', '火', '水', '木', '金', '土', 日]
  ]);
}
[view/foreach_loop.blade.php]
<table class="table">
<tr>
<th>値</th>
<th>index</th>
<th>iteration</th>
<th>count</th>
<th>first</th>
<th>last</th>
<th>even</th>
<th>odd</th>
<th>depth</th>
</tr>
@foreach ($weeks as $week)
<tr>
<td>{{ $week }}</td>
<td>{{ $loop->index }}</td>
<td>{{ $loop->iteration }}</td>
<td>{{ $loop->count }}</td>
<td>{{ $loop->first }}</td>
<td>{{ $loop->last }}</td>
<td>{{ $loop->even }}</td>
<td>{{ $loop->odd }}</td>
<td>{{ $loop->depth }}</td>
</tr>
@endforeach
----------------------------------

＠配列が空の場合の出力を決める  @forelse
@foreachディレクティブの変化形として、@forelseディレクティブもある。
@forelseの用法はほぼ@foreachと同じだが、配下に@empty句を置ける点が異なる。
----------------------------------
[view/forelse.blade.php]
@forelse ($records as $record)
<tr>
...
</tr>
@empty
<p>データは存在しません</p>
@endforelse
----------------------------------
これで、配列が空の場合、その旨がメッセージ表示されるようになる。
データの有無によって表示を振り分けるならば、@ifディレクティブよりもこちらがお
すすめ。
==================================

＠ループを即座に脱出する  @break
@breakディレクティブを利用することで、即座にループを終了できる。
----------------------------------
[view/foreach_loop.blade.php]
@foreach ($weeks as $week)
  @break($loop->iteration > 3)
<tr>
...
</tr>
@endforeach
----------------------------------
@breakディレクティブの引数には、ループの終了条件を指定する。
条件式を省略した場合には、無条件にループは終了する。
==================================

＠現在の周回をスキップする  @continue
@continueディレクティブは、（ループ全体を終了するのではなく）現在の周回を終了
し、次の集会へとスキップする。
----------------------------------
[view/foreach_loop.blade.php]
@foreach ($weeks as $week)
@continue($loop->odd)
<tr>
...
</tr>
@endforeach
----------------------------------
@continueディレクティブの引数には、@breakディレクティブと同じ意味。
==================================

＠任意のコードを実行する  @php
@phpディレクティブを利用することで、テンプレートに任意のコードを埋め込める。
が、基本的に@phpの利用は例外的と考えること。
テンプレートに混在するコードは、テンプレートの見通しを悪くする。
@phpが現れる状況では、まずそのコードがアクション／モデルで表せないかを考えるこ
と。
----------------------------------
＊Bladeを利用しない選択肢
そもそもBladeに頼らず、<?php ...?>だけでテンプレートを表すことも可能。
「使い慣れたPHPの構文でビュー開発したい」「ビューで表すべき@phpのコードが多い
」場合には有用である。
以下は、hello/view.blade.phpをBlade構文を利用せずに書き換えたもの。
----------------------------------
[hello/view.php]
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>速習Laravel</title>
</head>
<body>
<?php print($msg); ?>
</body>
</html>
----------------------------------
このサンプルを確認するには、Blade番号のテンプレートをあらかじめ退避しておくこ
と。
同じ名前のテンプレート（.phpと.blade.php）が存在する場合、blade.phpファイルが
優先されるから。
==================================

4.3 レイアウト
＠レイアウトテンプレート
レイアウト（レイアウトテンプレート）とは、いわゆるサイトデザインの外枠。
あらかじめ見た目の共通部分（ヘッダやフッタなど）をレイアウトにまとめておくこと
で、個々のテンプレートファイルでは差分のコンテンツだけを定義すればよいので、重
複を除去できる。
----------------------------------
その他、レイアウトを利用することで、以下のメリットがある。
・サイト構成（ナビゲーションなど）が一貫するので、使い勝手も向上する。
・サイトデザインを変更するにも共通レイアウトだけを編集すればよい。
----------------------------------
開発性、保守性、利便性の面で、レイアウトは有効である。
==================================

＠レイアウトの定義
レイアウトは、それ自体、Bladeテンプレートの一種に過ぎない。
ただし、他のテンプレートとは区別して、/resources/views/layoutsに配置することが
推奨される。
----------------------------------
[base.blade.php]
<!DOCTYPE html>
<html lang="ja">
<head>
<meta cherset="utf-8">
<!-- titleの置き場所 -->
<title>@yield('title')</title>
<!-- Bootstrapのインポート -->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"/>
</head>
<body>
<img src="https://wings.msn.to/image/wings.jpg" title="ロゴ">
<hr>
<!--  mainコンテンツの置き場 -->
@section('main')
<p>既定のコンテンツです</p>
@show
<hr>
<p>Copyright(c) 1998-2019,WINGS Project. All Right Reserved.</p>
</body>
</html>
----------------------------------
レイアウトを定義するには、@yield、@section...@showディレクティブを利用するのが
基本。
いずれも、個別のテンプレートからコンテンツを受け取る置き場所（セクション）を表
す。
双方の使い分けは、簡単なプレイスホルダーであれば、@yieldで十分。
----------------------------------
@yieldディレクティブ
@yield(name[,default])
・name：セクションの名前
・default：既定のコンテンツ
----------------------------------
例では、titleという名前のセクションを用意している。
既定値を指定することもできるが、引数何オデ、ごく簡単な文字列にとどめるのが一般
的。
複数行に渡るタグ文字列を既定値にするならば、@section...@showを利用すべき。
----------------------------------
@section...@showディレクティブ
@section(name)
  ...default...
@show
・name：セクションの名前
・default：既定のコンテンツ
----------------------------------
例では、mainという名前のセクションを用意している。
@sectionは、@showで閉じることに注意。
==================================

＠個別テンプレートの用意
準備したレイアウトは、それ自体では枠組みに過ぎないので、これに不足したコンテン
ツをはめ込んでみる。
----------------------------------
[ViewConroller.php]
public function master()
{
  return view('view.master', [
    'msg'=>'こんにちは、世界！',
  ]);
}
[master.blade.php]
<!-- 利用する共通レイアウトを宣言 -->
@extends('layouts.base')
<!-- titleセクションのコンテンツ -->
@section('title', '共通レイアウトの基本')
<!-- mainセクションのコンテンツ -->
@section('main'
<p>{{ $msg }}</p>
@endsection
----------------------------------
まず、@extendsディレクティブで、現在のページに適用すべき共通レイアウトを宣言す
る。
----------------------------------
@extends(path)
・path：共通レイアウトのパス
pathの表記は、viewメソッドのそれと同じである（拡張子は取り除き、/は.で表す）。
----------------------------------
あとは、共通レイアウトに対して@sectionディレクティブで、個別にコンテンツをはめ
込んでいく。
ただし、個別テンプレート側の@sectionには用途に応じて、構文も複数存在する。
----------------------------------
@section(name, value)
・name：セクションの名前
・value：任意の文字列
引数nameは、共通テンプレートの@yield/@sectionで指定した名前。
これに対応するセクションに、指定された値（value）が埋め込まれる。
----------------------------------
@section(name)
...contents...
@endsection
・name：セクションの名前
・contents：任意の文字列
複数行の場合。
----------------------------------
また、ブロック構文では、@parentディレクティブで共通レイアウト側のコンテンツを
埋め込むことも可能。
@section('main')
@parent
<p>{{ $msg }}</p>
@endsection
==================================

＠コンポーネント
コンポーネントとは、断片的なテンプレートのこと。
レイアウトがサイト共通の枠組み（ヘッダ、フッタなど）を定義するための仕組みであ
るとすれば、コンポーネント（サイト共通でないにせよ）複数のページで共有するよう
な、より小粒な部品を切り出すための仕組み。
以下は、サイト内でアラートボックスを表示するためのコンポーネントの定義とその使
用例。
----------------------------------
＊コンポーネントの定義
Bladeの世界では、コンポーネントもまた、標準的なテンプレートに過ぎない。
が、区別のため、resources/views/componentsに配置するとよい。
[alert.blade.php]
<div class="alwert alert-{{ $type }}">
<h4 class="alwert-heading">{{ $alert_title }}</h4>
<p>{{ $slot }}</p>
</div>
----------------------------------
＊コンポーネントの利用
定義済みのコンポーネントを引用するには、@componentディレクティブを利用する。
[view/comp.blade.php]
@extends('layouts.base')
@section('title', '共通レイアウトの基本')
@section('main')
  @component('components.alert', ['type'=>'success'])
    @slot('alert_title')
    はじめてのコンポーネント
    @endslot
    コンポーネントは普通のビューと同じように.blade.phpファイルで定義できる。
  @endcomponent
@endsection
----------------------------------
@component(path, params)
  ...body...
@endcomponent
・path：コンポーネントのパス
・params：コンポーネントに渡す変数情報
・body：コンポーネントの本体
----------------------------------
pathは、これまでと同じ形式。
paramsに変数を渡す方法は「名前=>値」の連想配列。
複数行に渡る文字列、またはタグ文字列を表す場合、@slot...@endslotを利用する。
@slotは、@component配下に必要なだけ列挙できる。
----------------------------------
@slot(name)
...body...
@endslot
・name：スロットの名前
・body：任意のコンテンツ
@slotで括られなかったコンテンツは$slotという変数に格納される。
一般的には、コンポーネント内のメインコンテンツは、@slotでは括らず、そのまま@co
mponent直下で表すのがシンプル。
==================================

＠サブビュー
コンポーネントとよく似た機能として、サブビューがある。
@includeディレクティブを利用する。
----------------------------------
[view/comp.blade.php]
@include('components.alert', ['type'=>'success'
  'alert_title'=>'はじめてのコンポーネント',
  'slot'=>'コンポーネントは普通のビューと同じように.blade.phpです。'
 ])
----------------------------------
サブビューにはスロットという概念はない。
よって全ての変数値は@includeの引数として渡す。
ただし、メインテンプレートで参照できる変数は、サブビューでもそのまま参照できる
ので、改めて引渡す必要はない。
==================================

＠コレクションビュー
コレクションビューは、コレクション（配列）に対して適用できる、特別なサブビュー
。
配列の各要素にサブビューを適用しながら順に出力するようなコードも、コレクション
ビューを利用することで簡単に実装できる。
----------------------------------
＊コレクションビューの準備
まずは配列ごとに適用する部分ビューを準備。
保存先に決まりはないが、/views/subviewsとしておく。
----------------------------------
[book.blade.php]
<tr>
<td>{{ $record->title }}</td>
<td>{{ $record->price }}円</td>
<td>{{ $record->publisher }}</td>
<td>{{ $record->published }}</td>
</tr>
コレクションビューで利用するテンプレートには、1項目ごとの（@foreachの配下で表
していたような）ビューを定義する。
仮引数は何でも構わない。
----------------------------------
＊空ビューを準備する
また、配列が空だった場合のテンプレートも用意しておく。
[empty.blade.php]
<p>書籍情報はありません。</p>
----------------------------------
＊コレクションビューを呼び出す
[view/list.blade.php]
@exetnds('layouts.base')
@section('title', '共通レイアウトの基本')
@section('main')
<table class="table">
<tr>
<th>書名</th>
<th>価格</th>
<th>出版日</th>
<th>刊行日</th>
</tr>
@each('subviews.book', $records, 'record', 'subviews.empty')
</table>
@endsection
----------------------------------
コレクションビューを呼び出すのは、@eachディレクティブ。
----------------------------------
@each(path, data, var, emp_path)
・path：コレクションビューのパス
・data：繰り返しに利用する配列
・var：仮変数（コレクションビューでの参照用）
・emp_path：配列dataが空の場合に表示するビュー（省略可能）
----------------------------------
@eachは、@foreach＋@include（＋@if）の組み合わせでも代用できる。
==================================

Part5：ルーティング

＠ルーティングの基本
Route::getメソッドがルート定義の基本（正しくはHTTP GET経由でのリクエストを処理
するのが、getメソッドの役割）。
例えばHTTP POST経由でのリクエストを処理するならば、POSTメソッドを利用する。
Route::post('/route/post', 'RouteController@post');
----------------------------------
その他、HTTPメソッドに対応して、以下のメソッドが用意されている。
・put
・patch
・delete
・options
複数のHTTPメソッドにまとめて対応するならば、matchメソッドもある。
例えば、HTTP GET/POSTに対応するルートを定義するならば以下のようにする。
Route::match(['get', 'post'], '/route/match', 'RouteController@match');
----------------------------------
HTTPメソッドを特定せず、すべてのHTTPメソッドに無条件に対応するならば、anyメソ
ッドを利用してもよい。
Route::any('/route/any', 'RouteController@any');
==================================

＠ルートパラメーター
例えば、「blog/20190625」のようなパスで、「20190625」のような値を、コントロー
ラー（アクション）に引渡すことができる。
パラメーター値をパスの一部として表現できるため、ルータ経由のの値の引き渡しとし
てよく利用される方法。
このようなパラメータをルートパラメータという。
==================================

＠ルートパラメーターの基本
まずは、ルートパラメーターを含んだルートを定義し、コントローラーからこれを受け
取ってみる。
----------------------------------
＊ルーティング情報を定義する
例えばRouteController@paramアクションに対して、idというパラメータを渡すには、
以下のようなルーティング情報を定義する。
[web.php]
use App\Http\Controllers\RouteController;
Route::get('route/param/{id}', [RouteController::class, 'param']);
----------------------------------
ポイントは、第1引数に含まれた{名前}の表記。
これがパラメータのプライスホルダで、{名前}の部分に「～/route/param/108」のよう
に自由に値を埋め込めることを意味する。
名前はアルファベット＋_で命名する（ハイフンは不可）。
以下のように複数のパラメタを設定しても構わない。
Route::get('blog/{year}/{month}/day}, [RouteController::class, '...']);
----------------------------------
＊ルートパラメタを受け取るアクションを準備する
[RouteController.php]
public function param(int $id)
{
  return 'id値：' . $id;
}
----------------------------------
ポイントとなるのは、仮引数。
アクションメソッドにルートパラメタを受け取るための引数を用意するだけ。
これによってLaravelが自動的に対応する値を引数に割り当ててくれる。
----------------------------------
＊任意パラメタ
ルートパラメタは既定では必須の扱いとなる。
よって「～/route/param」二は一致しない。
もしも任意パラメタを指定したいなら、パラメタ名の末尾に「?」を付ける。
----------------------------------
任意パラメタの場合、アクションの側で既定値を明示しておかなければならない。
public function param(int $id=1)
----------------------------------
＊ルートパラメタの制約
受け取るべきルートパラメータの値があらかじめ想定できている場合、正規表現の形で
値の形式を制限することもできる。
----------------------------------
Route::get('route/param/{id?}, [RouteController::class, 'param'])
->where(['id'=>['0-9]{2,3}']);
----------------------------------
正規表現の制約は、ルート定義の後方のwhereメソッドで宣言する。
引数は「パラメタ名=>正規表現」形式の連想配列なので、複数になった場合も配列要素
を列挙するだけ。
==================================

＠ルートパラメタのグローバル制約
ルートをまたがって、特定のパラメタに対して制約を付与したい場合は、/app/provide
rs/RouteServiceProvider.phpに対して、以下のpattern...を追加する。
これですべての{id}パラメタに対して正規表現による制約が付与される。
public vunction boot()
{
  Route::pattern('id', '[0-9]{2,3}');
  parent::boot();
}  
==================================

＠ルートパラメタの可変長パラメタ
正規表現を用いることで、可変長パラメタも表現できる。
たとえば「～/search/laravel/php/framework」であれば、「～/search/」以降の「lar
avel/php/framework」をまとめて一つの変数で受け取れるようなパラメタのこと。
任意個数のパラメタを扱いたい場合に便利。
[web.php]
Route::get('route/search/{keywd?}', [RouteController::class, 'search')
->where('keywd', '.*')
----------------------------------
「.*」で「/」を含めた任意の文字が0以上という意味になる。
これで、keywdパラメタは、「laravel/php/framework」のようなスラッシュ区切りの文
字列となる。
よって、利用側ではスラッシュで値を分割してから利用することになる。
==================================

＠ルートに共通の接頭辞を付与する
たとえば会員向けのページに対して、「/members」のような共通のパス接頭辞を付与し
たい場合がある。
その場合、prefixメソッドを利用することで、共通の接頭辞をまとめて宣言できる。
以下は、/members/info、/members/articleルートを定義する例。
----------------------------------
[web.php]
Route::prefix('mebers')->group(function() {
  Route::get('info'), [RouteController::class, 'info']);
  Route::get('article'), [RouteController::class, 'article']);
  ...
});
----------------------------------
このように、ルート定義を意味的な役割の単位に束ねる仕組みをルートグループという
。
==================================

＠名前空間付きのコントローラー
ルートグループを利用することで、名前空間付きのコントローラを束ねることもできる
。
名前空間付きとは、既定の名前空間（App/Http/Controllers）配下のサブ名前空間に属
するコントローラーのこと。
ある程度の規模のアプリであれば、複数の名前空間に分けることで、ファイルの見通し
も改善する。
----------------------------------
このような名前空間付きのコントローラにルートを割り当てるには、namespaceメソッ
ドを利用する。
例えば、以下は、App\Http\Controllers\Main名前空間に属するRouteControllerコント
ローラーを定義する例。
----------------------------------
[web.php]
Route::namespace('Main')->group(function() {
  Route::get('route/ns', [RouteController::class, 'ns');
});
==================================

＠ルートの定義  アクションの省略
アクションによる処理を必要としない場合（＝指定のビューを表示するだけの場合には
、viewメソッドでビューを直接に指定できる。
----------------------------------
[web.php]
Route::view('/route', 'route.view',['name'=>'Laravel']);
----------------------------------
これで、「/routeにたいして、route/view.blade.phpを返す」という意味になる。
第3引数には、ビュー変数を渡すこともできるので、簡単な値の引き渡しであれば、vie
wメソッドで十分に賄える。
==================================

＠ルートの定義  リダイレクト
特定のパスを別のルートにリダイレクトするには、redirectを利用する。
以下は、「/hoge」を「/」に振り分ける例。
[web.php]
Route::redirect('/hoge', '/');
----------------------------------
redirectメソッドは、既定で「302 Found」（一時的な移動）を返す。
恒久的なページ移動を表すなら「301 Moved Permanently」を指定するとよい。
Route::redirect('/hoge', '/', 301);
適切なステータスコードの指定は、検索エンジンに正しいページを認識してもらう、と
いう意味でも有効。
==================================

＠ルートの定義  リソースルート
resourceメソッドを利用することで、典型的なCRUD（Create-Read-Update-Delete）ア
クションをまとめてルート定義できる。
[web.php]
Route::resource('articles', 'ArticleController');
----------------------------------
resource宣言によって、具体的には、以下のようなルートが定義される。
メソッド   パス                    アクション名      概要
GET        /articles                index             一覧の表示
GET        /articles/{article}      show              詳細の表示
GET        /articles/create         create            登録フォーム
POST       /articles                store             登録処理
GET        /articles/{article}/edit edit              編集フォーム
PUT/PATCH  /articles/{article}      update            更新処理
DELETE     /articles/{article}      destroy           削除処理
----------------------------------
特定のルート（アクション）を無効化するならば、exceptメソッドを利用する。
例えば以下は、edit/updateメソッドを除外する。
[web.php]
Route::resource('articles', 'ArticleController')
->except(['edit', 'update']);
----------------------------------
resourcesメソッド（複数形）によって、複数のリソースルートをまとめて定義するこ
とも可能。
引数の形式は「パス=>コントローラー」。
Route::resources([
  'articles'=>'ArticleController',
  ...
]);
----------------------------------
＊リソースコントローラー
リソースルートに対応するコントローラーは、以下のコマンドで自動生成できる。
>php artisan make:controller ArticleController --resource --model=Article
標準的なコントローラー作成コマンドに、resource/modelオプションを指定する。
modelオプションは、アクションの引数に対応するモデルを割り当てることを意味する
。
==================================

＠ルートの定義  フォールバックルート
fallbackメソッドを利用することで、どのルートにもマッチしない場合、最終的に実行
すべきルート（フォールバックルート）を定義できる。
例えば以下は、存在しないページ（ルート）が指定された場合に、独自のエラーページ
（route/error.blade.php）を表示する例。
----------------------------------
[web.php]
Route::fallback(function() {
  return view('route.error');
});
==================================

＠ルートの優先順位
web.phpでルートを追加する順序はとても大事。
ルートの優先順位はそのまま記述の順序によって決まるから。
よって、汎用的な、たとえば「{hoge}/{id}」のようなルートはできるだけ後方に記述
すべき。
同じ理由から、フォールバックルートは、すべてのルートの末尾で宣言しなくてはなら
ない。
==================================

Part6 コントローラー開発

＠Responseクラス
クライアントへの応答を操作するのがResponseクラス（Illuminate\Http名前空間）。
Laravelでは、まずはviewメソッドでレスポンスを生成するのが基本。
しかし、Responseクラスを利用することで、ステータス／ヘッダ情報を指定したり、コ
ンテンツをファイルとしてダウンロードさせたり、といった細かな制御が可能となる。
==================================

＠Responseオブジェクトの基本
Responseオブジェクトを取得するには、responseヘルパーを呼び出すのが簡単。
以下は、プレーンなテキストをResponseオブジェクト経由で出力する例。
----------------------------------
[CtrlController.php]
public function plain() {
  return response('こんにちは、世界！', 200)
          ->header('Content-Type', 'text-plain');
  }
}
----------------------------------
＊responseヘルパー
response([text[, status[, headers]])
・text：レスポンス本体
・status：応答ステータス
・headers：応答ヘッダー
----------------------------------
上記の例は、
return 'こんにちは、世界！';
としてもほぼ同じ意味。
が、Responseオブジェクトを介することで、応答ステータス／ヘッダ情報を付与できる
。
responseヘルパーそのもので指定できるだけでなく、responseヘルパーによって得られ
たResponseオブジェクトに対して、さらにメソッドチェーンで情報を付与できる。
（上記の例ではheaderメソッド）
==================================

＠ビュー出力時にヘッダを設定する
Responseオブジェクトを経由することで、ビュー（テンプレート）経由での出力時にも
、HTTPステータス／レスポンスヘッダ―を指定できる。
これには、responseメソッド経由でview/headeerメソッドを呼び出す。
----------------------------------
[CtrlController.php]
public function header()
{
  return response()
    ->view('ctrl.header, ['msg'=>'こんにちは、世界！'], 200)
    ->header('Content-Type', 'text/xml');
}
----------------------------------
複数のヘッダをまとめて付与するならば、withHeadersメソッドを利用指定も構わない
。
return response()
  ->view('ctrl.header', ['msg'=>'こんにちは、世界！'], 200)
  ->withHeaders([
    'Content-Type': 'text/xml',
    'X-Powered-FW'=>'Laravel/6'
  ]);
==================================

＠JSON形式の出力を生成する
responseメソッド経由でjsonメソッドを呼び出すことで、JSON形式の応答も生成できる
。
----------------------------------
[CtrlController.php]
public function outJson()
{
  return response()
    ->json([
      'name'=>'Yoshihiro, YAMADA',
      'sex'=>'male',
      'age'=>18,
    ]);
}
----------------------------------
JSONP形式の応答を生成するならば、更にwithCallbackメソッドを呼び出す。
return response()
    ->json([
      'name'=>'Yoshihiro, YAMADA',
      'sex'=>'male',
      'age'=>18,
    ])
    ->withCallback('callback');
----------------------------------
＊配列を返すアクションメソッド
ヘッダの追加、JSONPへの整形が不要であれば、アクションの戻り値を連想配列形式と
しても構わない。
連想配列形式の戻り値は、LaravelがJSON形式に変換したうえで出力してくれるからで
ある。
よって、以下のように書いても同じ。
public function outJson()
{
  return [
    'name'=>'Yoshihiro, YAMADA',
    'sex'=>'male',
    'age'=>18
  ];
}
==================================

＠指定されたファイル／データをダウンロードする
responseメソッド経由でdownloadメソッドを呼び出す。
----------------------------------
[CtrlController.php]
public function outFile()
{
  return response()
    ->download('C:/Data/data_log.csv', 'download.csv',
               ['content-type'=>'text/csv']);
}
----------------------------------
これで「C:/Data/data_log.csv」をdownload.csvという名前でダウンロードさせなさい
、という意味になる。
----------------------------------
（ファイルではなく）生成したデータをダウンロードさせたい場合は、streamDownload
メソッドを利用する。
----------------------------------
[CtrlController.php]
public function outCsv()
{
  return response()
    ->streamDownload(function() {
      print(
        "1,2019/10/1,123\n".
        "2,2019/10/2,116\n".
        "3,2019/10/3,98\n".
        "4,2019/10/4,102\n".
        "5,2019/10/5,134\n"
      );
    }, 'download.csv', ['content-type'=>'text-csv']);
}
----------------------------------
downloadメソッドでは第1引数にファイルパスを指定したところが、コールバック関数
になっているだけ。
関数の中では、クライアントに送出すべきデータを出力する。
（実際のアプリでは、データベースなどから動的に生成する、などする。）
----------------------------------
＊指定されたファイルを出力する
fileメソッドを利用することで、ダウンロードする代わりに、指定されたファイルをそ
のままブラウザに描画することもできる。
----------------------------------
[CtrlController.php]
public function outImage()
{
  return response()
    ->file('c:/Data/wings.png', ['content-type'=>'image/png']);
}
==================================

＠リダイレクト
アクションを処理した後、任意のページにリダイレクトするなら、redirectメソッドを
利用する。
----------------------------------
[CtrlController.php]
public function redirectBasic()
{
  return redirect('hello/list');
}
----------------------------------
パスではなく、ルート名でリダイレクト先を表すならば、redirect()->routeメソッド
を利用する。
return redirect()->route('list');
----------------------------------
routeメソッドを利用する際には、以下のようにルート側でも名前を宣言しておく。
----------------------------------
[web.php]
Route::get('hello/list', [HelloCntroller::class, 'list'])
  ->name('list');
----------------------------------
ルートが何らかのパラメタを要求する場合には、routeメソッドに「名前=>値」形式で
パラメタ情報を渡す。
return redirect()->route('param', ['id'=>108]);
----------------------------------
＊アクションへのリダイレクト
actionメソッドを利用することで、アクションメソッドに対して処理をリダイレクトす
ることも可能。
第2引数経由でパラメタ情報を渡せる点は、routeメソッドと同じ。
return redirect()->action([RouteController::class, 'param'], ['id'=>108]);
----------------------------------
＊外部サイトへのリダイレクト
現在のアプリではなく、外部のサイトに移動したい場合は、awayメソッドを利用する。
return redirect()->away('https://wings.msn.to/');
==================================

＠リクエスト
Responseに対して、リクエスト情報を管理するならば、Requestクラス（Illuminate\Ht
tp名前空間）を利用する。
フォーム入力、クエリ情報、リクエストヘッダ、パスなど、クライアント情報にアクセ
スするための手段を提供する。
==================================

＠Requestオブジェクトの基本
Requestオブジェクトを利用するには、アクションに対してRequest型の引数を追加する
だけ。
これによって、アクション呼び出しの際にLaravelからRequestオブジェクトが渡される
ようになる。
----------------------------------
[CtrlController.php]
use Illuminate\Http\Request;
...
public function index(Request $req)
{
  return 'リクエストパス：'. $req->path();
}
----------------------------------
あるいは、requestヘルパーを利用して以下のようにも表せる。
return 'リクエストパス：' . request()->path();
----------------------------------
ここでは、Request#pathメソッドでリクエスト時のパスを取得しているが、その他、以
下のようなメンバが公開されている。
・header(key[, def])  ヘッダー値を取得
・hasHeader(key)  指定されたヘッダが存在するか
・server(key[, def])  サーバ環境変数を取得
・root()  アプリの基底URLを取得
・url()  リクエストURLを取得（クエリ情報なし）
・fullUrl()  リクエストURLを取得
・path()  リクエストパスを取得
・is(ptns)  リクエストURLが指定のパターンにマッチするか
・ip()  クライアントのIPアドレスを取得
・userAgent()  ユーザエージェントを取得
----------------------------------
Requestオブジェクトとルートパラメタを同時に利用することもできる。
これには、Request型引数の後方に、ルートパラメタを受け取るべき引数を配置するだ
け。
public function hoge(Request $req, $id) { ... }
==================================

＠フォームからの入力
HTMLフォームからの入力も、Requestオブジェクトから取得できる。
----------------------------------
＊入力フォームの準備
[CtrlController.php]
public function form()
{
  return view('ctrl.form', ['result'=>'']);
}
[ctrl/form.blade.php]
@extends('layout.base')
@section('title', 'フォームの基本')
@section('main')
<form method="POST" action="/ctrl/result">
  <!-- CSRF対策 -->
@csrf
<label for="name">名前：</label>
<input id="name" name="name" type="text" value="">
<input type="submit" value="送信">
</form>
@endsection
----------------------------------
@csrfヘルパーは、CSRF対策のためのディレクティブ。
@csrfを付与して生成されたフォームでは、以下のような隠しフィールドが生成される
。
<input type="hidden" name="_token"
  value="N0CR85wWgUCT6Nr0cIXZYwBRB4l4z09MqItXlRv9k2>
この入力値が正しいフォームから送信されているかどうかを証明するための文字列で、
ワンタイムトークンとも呼ばれる。
アクションメソッドでは、あらかじめ手元で生成されたワンタイムトークンと、フォー
ムから送信されたそれが一致するかを確認し、一致する場合にだけデータを受け入れる
。
ワンタイムトークンはランダムに生成された文字列なので、第三者が推測することは困
難。
よって、正しいトークンが送信されたということは、正しいフォームから送信されたと
いうことになる。
まずは最低限、入力フォームを生成する際には、<form>要素の配下に@csrfディレクテ
ィブを配置すること。
----------------------------------
＊フォーム入力の処理
[CtrlController.php]
public function result(Request $req)
{
  $name = $req->name;
  return view('ctrl.form', ['result'=>'こんにちは'.$name.'さん！']);
}
----------------------------------
入力フォームからの送信値を取得するには、「$req->要素名」とするだけ。
要素名とは、name属性で指定された名前。
このように、にゅうりょくフォームに応じてRequestオブジェクトに付与されるプロパ
ティを動的プロパティという。
もしも、入力値がない場合の既定値を準備したいならば、inputメソッドを利用する。
第2引数が既定値。
$name = $req->input('name', '名無し権兵衛');
----------------------------------
＊resultアクションのルート定義
routeアクションのルートは、<form method="POST">（＝HTTP POST）経由で呼び出され
ることを想定している。
よって、ルート定義はRoute::postを使う。
Route::post('ctrl/result', [CtrlController::class, 'result']);
==================================

＠ファイルのアップロード
動的プロパティ構文を利用することで、アップロードされたファイルを受け取ることも
できる。
[CtrlController.php]
public function upload()
{
  return view('ctrl.upload', ['result=>'']);
}
public function uploadfile(Request $req)
{
  if (!$req->hasFile('upfile')) {
    return 'ファイルを指定してください。';
  }
  $file = $req->upfile;
  if (!$file->isValid()) {
    return 'アップロードに失敗しました。';
  }
  $name = $file->getClientoriginalName();
  $file->storeAs('files', $name);
  return view('ctrl.upload', [
    'result'=>$name . 'をアップロードしました。'
  });
}
[ctrl/upload.blade.php]
@extends('layouts.base')
@section('title', 'アップロードの基本')
@section('main')
<form method="POST" action="/ctrl/uploadfile" enctype="muitipart/form-data">
@csrf
<input id="upfile" name="upfile" type="file">
<input type="submit" value="送信">
<p>{{ $result }}</p>
</form>
@endsection
----------------------------------
アップロードファイルを取得するには、ポストデータと同じく「$req->要素名」のよう
に表す。
取得する前にそもそもファイルが存在するかどうかを確認するならばhasFileメソッド
を利用する。
isValidメソッドは、アップロードに成功したかを確認している。
「$req->要素名」の戻り値は、アップロードの場合はUploadFileクラス（Illuminate\H
ttp名前空間）。
UploadFileクラスは、PHP標準のSplFileInfoクラスを拡張したクラスで、以下のような
メソッドを提供している。
・getClientOriginalName  オリジナルのファイル名
・getClientOriginalExtension  オリジナルのファイル拡張子
・getClientMimeType  オリジナルのファイルタイプ
・getClientSize  オリジナルのファイルサイズ
・getErrorMessage  アップロード時のエラー情報
・storeAs  ファイルを指定の場所に保存
----------------------------------
ファイルを保存するのは、storeAsメソッドの役割。
storeAs(path, name)
・path  保存先のフォルダ（/storage/appフォルダからの相対パス）
・name  保存時のファイル名
==================================

＠ミドルウェア
アクションメソッドの前後で付随的な処理を実行するためのしくみ。
フィルターを利用することで、アクションに付随する共通の処理、例えばロギングや認
証といった機能をアクションごとに記述しなくて済むようになる。
==================================

＠ミドルウェアの基本
以下は、アクションを実行する都度、指定されたファイルに現在時刻を記録するLogMid
dlewareの例。
----------------------------------
[1]ミドルウェアを作成する
ミドルウェアの骨組みは、以下のコマンドで作成できる。
-----------------
>php artisan make:middleware LogMiddleware
-----------------
これにより、App/Http/Middlewareフォルダ配下にLogMiddleware.phpが生成される。
以下、access.logにアクセス時刻を記録するためのコード。
-----------------
[LogMiddleware.php]
<?php
namespace App\Http\Middleware;
use Closure;
class LogMiddleware 
{
  // a. ミドルウェアの実処理
  public function handle($request, Closure $next)
  {
    file_put_contents('c:/data/access.log', 
          date('Y-m-d H:i:s')."\n", FILE_APPENDED);
    // b. 次のミドルウェアを呼び出し
    return $next($request);
  }
}
?>
-----------------
ミドルウェアであることの条件は、handleメソッドを持つことだけ。
-----------------
handle(request, next)
・request：リクエスト情報
・next：クロージャ―（Closure）
-----------------
一般的なミドルウェアでは、request経由で、たとえばアクション共通で利用するビュ
ー変数を登録するなどの処理を記述したりする。
ビュー変数を追加するには、mergeメソッドを利用する。
-----------------
$request->merge([
  'title'=>'速習Laravel',
  'author'=>'YAMADA, Yoshihiro'
]);
-----------------
handleメソッドでは、最後にnext（Closure）を呼び出し、戻り値として返すのが基本
。
これにより、次のミドルウェア（存在しない場合は本来のアクション）が呼び出される
。
$nextの引数には$request（リクエスト情報）を渡しておく。
----------------------------------
[2]アプリにミドルウェアを登録する
ミドルウェアを定義した後は、どのアクションの前後で呼び出すのかを紐づけしなくて
はならない。
これにはルーティング設定に対して、middlewareメソッドを追加するだけ。
-----------------
[web.php]
use App\Http\Middleware\LogMiddleware;
...
Route::get('ctrl/middle', [CtrlController::class, 'middle')
  ->middleware(LogMiddleware::class);
-----------------
これで、「~/ctrl/middleを処理する際にLogMiddlewareを呼び出す」という意味になる
。
一つのルートに対して、複数のミドルウェアを紐づけたい場合は、カンマ区切りで指定
する。
-----------------
Route::get(...)->middleware(LogMiddleware::class, HogeMiddleware::class);
----------------------------------
[3]アクションを準備する
あとは、ミドルウェアを紐づけたアクション（コントローラー）を準備するだけ。
-----------------
[CtrlController.php]
public function middle()
{
  return 'log is recorded!!';
}
-----------------
以上で、「~/ctrl/middle」にアクセスすると、access.logに現在時刻が記録される。
==================================

＠アクションの後処理
アクションの実行後に処理したい場合、以下のようにhandleメソッドを記述する。
以下は、アクション側で生成されたコンテンツを大文字に変換する例。
-----------------
[LogMiddleware.php]
public function handle($request, Closure $next)
{
  file_put_contents('c:/data/access.log, 
    date('Y-m-d H:i:s')."/n", FILE_APPEND);
  //a. アクションを実行
  $response = $next($request);
  //b. レスポンスの内容を加工
  $response->setContent(mb_strtoupper($resonse->content()));
  return $response;
}
-----------------
アクションの後処理を行うには、$nextメソッドを見日出して、その戻り値（Response
オブジェクト）に対して処理を実行する。
handleメソッドの最終的な戻り値はResponseオブジェクトとする。
==================================

＠ミドルウェアのさまざまな登録方法
ルート個々に登録するほか、以下のような方法がある。
----------------------------------
＊グローバルミドルウェア
アクション（コントローラー）を跨る共通処理を再利用するという趣旨からすると、個
々のルートに都度登録するのは面倒。
そのような場合には、アプリ全体にミドルウェアを一括登録する（グローバルミドルウ
ェア）。
これには、App/Http/Kernel.phpを以下のように編集する。
-----------------
protected $middleware = [
  ...
  \App\http\Middleware\TrustProxies::class,
  \App\Http\Middleware\LogMiddleware::class,
];
-----------------
$middlewareプロパティ（配列）の末尾に、準備済みのミドルウェアを追加するだけ。
また、（web.phpでの）ルート単位のミドルウェア定義は削除しておく。
この状態で、アプリは以下の任意のパスにアクセスすると、access.logに現在時刻が記
録されるようになる。
----------------------------------
＊ミドルウェアグループ
ミドルウェアの用途に応じて、グループ化することも可能。
グループ化することで、たとえばデバッグ用途のミドルウェアをdebugグループにまと
めておいて、グループとしてルートに紐づけすることができる。
ミドルウェアグループを定義するにはKernel.phpに以下のように記述する。
-----------------
[Kernel.php]
protected $middlewareGroups = [
  'web'=>[...],
  'api'=>[...],
  'debug'=>[
    \App\Http\Middleware\LogMiddleware::class,
  ],
];
-----------------
$middlewareGroupsプロパティは「グループ名=>ミドルウェア（群）」形式の連想配列
。
既定で、web/apiグループが用意されているので、その後方に自前のグループを追加す
る。
グループを登録出来たら、groupメソッドでルート単位でグループを紐づける。
-----------------
[web.php]
Route::group(['middleware=>['debug']], function() {
  Route::get('ctrl/middle', [CtrlController::class, 'middle']);
});
-----------------
groupメソッド配下には、複数のルートを列挙可能。
----------------------------------
＊コントローラーでの登録
コントローラー内で（＝コントローラー内部での複数のアクション）でのみ適用するミ
ドルウェアであれば、コンストラクタ配下で定義する方法もある。
-----------------
[CtrlController.php]
class CtrlController extrends Controller
{
  public function __construtct()
  {
    $this->middleware(function($request, $next) {
    ...
    return $next($request);
  });
  }
}
-----------------
特定のアクションに対してのみ（あるいは、特定のアクションを除いて）、ミドルウェ
アを適用するなら、only/exceptメソッドを利用する。
以下は、basic/basic2アクションでのみミドルウェアを適用する。
-----------------
$this->middleware(function($request, $next) {
  ...
  return $next($request);
})->only(['basic', 'basic2']);
==================================

Part 7 状態管理

＠状態管理
状態管理とは、複数ページ（アクション）間で情報を維持するための仕組みのこと。
HTTPはステートレスプロトコル。
クライアントからの要求に対して、サーバが応答して、それで終わり。
同じクライアントからつぎの要求を送信しても、サーバは同じクライアントからのもの
とはみなさない。
そこでLaravelでは、複数の要求間で情報を維持するため、以下のような機能を提供し
ている。
・クッキー：ブラウザに保存する小さなテキスト情報
・セッション：ファイル、データベースなどに情報を保存する仕組み
・フラッシュ：現在と次のリクエストでのみ保存される特別なセッション

＠クッキー
ブラウザに簡単なテキスト情報を保存するなら、クッキーを利用する。
ブラウザ標準の仕組みなので、たとえばJavaScriptとLaravel（PHP）間でクッキーを共
有することも可能。
----------------------------------
＊クッキーの保存
クッキーを保存するには、Responseオブジェクトのcookieメソッドを利用する。
-----------------
[StateController.php]
public function recCookie()
{
  return response()
    ->view('state.view'
    ->cookie('app_title', 'laravel', 60*24*30);
}
-----------------
cookieメソッドの引数は、「名前」「値」「有効期限（分）」「パス」「ドメイン」「
HTTPSのみで送信するか（true/false」)。
有効期限を省略した場合は、ブラウザを閉じたタイミングでクッキーも削除される。
この例であれば、「名前app_title、値laravel、有効期限30日間」であるクッキーを発
行している。
----------------------------------
＊値は暗号化される
Laravelで発行されたクッキーは、改ざんされないよう、暗号化された状態で保存され
る。
JavaScriptと連携させたいなど、暗号化そのものを無効化したい場合には、/App/Http/
Middoelwareフォルダ配下のEncryptCookies.phpを編集する。
protected $except = [
  'app_title'
];
EncriyptCookiesクラス配下に$exceptフィールド（配列）が用意されているので、その
配下に暗号化しないクッキーの名前を列記する。
----------------------------------
＊クッキーの取得
保存したクッキーを取得するには、Requestオブジェクトのcookieメソッドにアクセス
するだけ。
-----------------
[StateController.php]
public function readCookie(Request $req)
{
  return view('state.readcookie', [
    'app_title'=>$req->cookie('qpp_title')
  ]);
}
-----------------
[state/readcookie.blade.php]
@extends('layout.base')
@section('title', 'クッキー')
@section('main')
<p>{{ $app_title }}</p>
@endsection
==================================

＠セッション
＠セッション
セッションを利用することで、（一般的には）アプリを開いてからブラウザを閉じるま
での期間で、情報を維持できる。
アプリを起動している間の情報維持なら、まずはセッションを優先して利用するとよい
。
==================================

＠セッション利用のための設定
セッションを利用するための設定情報は、/config/session.phpで宣言されている。
中身は「設定名=>値」の連想配列。
-----------------
[session.php]
'drvier'=>env('SESSION_DRIVER', 'file'),
-----------------
driverキーで、セッションの保存先を設定できる。
既定値はfileで、保存先は/storage/framework/sessionsフォルダ。
その他、以下のような保存先（ドライバ）を設定できる。
・file：ファイル
・cookie：暗号化クッキー
・database：リレーショナルデータベース
・memcached/redis：キャッシュサーバ
・array：配列
-----------------
arrayは、テストのためのモード。
==================================

＠セッションの利用
セッションを取得／設定するには、Requestオブジェクトのsessionメソッドを利用する
。
-----------------
[StateController.php]
public function sesion1(Request $req)
{
  $req->session()->put('series', '速習シリーズ');
  return 'セッションを保存しました。';
}
public function session2(Request $req)
{
  $series = $req->session()->get('series','未定');
  return 'シリーズ：' . $series;
}
-----------------
セッションに値を出し入れするには、sessionメソッド経由でput/getメソッドを呼び出
すだけ。
-----------------
put(name, value)
get(name, default)
・name：名前
・value：値
・default：既定値
引数defaultは、以下のように関数でも可能。
その場合、戻り値が既定値とみなされる。
-----------------
$series = $req->session()->get('series', function() {
  return '未定';
});
----------------------------------
＊別解：session関数
session関数を利用してもよい。
-----------------
session(['key'=>'value']);
$value = session('key', 'default value');
==================================

＠セッションのさまざまな動作
put/getメソッドの他、以下のようなメソッドが用意されている。
・all()
全てのセッション値を取得
・pull(key, default)
指定したキーの値を取得した後削除（defaultは既定値）
・has(key)
指定したキーが存在するかを判定（nullもfalse）
・exists(key)
指定したキーが損じするかを判定（nullはtrue）
・push(key, value)
指定したキー（配列）に値を追加
・forget(key)
指定されたキーを削除
・flush()
全てのセッションデータを削除
・flash(key, value)
指定されたキーをフラッシュデータとして追加
・reflash()
フラッシュデータを次のページに持ち越し（すべて）
・keep([key, ...])
フラッシュデータを次のページに持ち越し(指定のキー）
・regenerate()
セッションIDの再生成
-----------------
フラッシュとは、現在のリクエストと次のリクエストでのみデータを維持する（それ以
降は自動で削除される）特殊なセッション。
短期間で消費されるメッセージの管理などに利用する。
==================================

＠フラッシュの利用例
フォーム入力について、以下のようなエラーチェックを行う例：
・〔名前〕欄が空でないか
・〔名前〕欄が10文字以内であるか
----------------------------------
＊resultアクション
public function result(Request $req)
{
  $name = $req->name;
  if (empty($name) || mb_stlen($name)>10) {
    return redirect('ctrl/form')
    ->withInput()
    ->with('alert', '名前は必須、または、10文字以内で入力してください');
  }
  else {
    return view('ctrl.form', [
      'result'=>'こんにちは、'.$req->name.'さん！'
    ]);
  }
}
-----------------
問題があった場合にフォームを再表示させのがredirect()。
ただし、そのままリダイレクトしてはフォームが元の状態に戻ってしまうので、入力値
をフラッシュに保存しておく。
これを行うのがwithInputメソッド。
また、エラーを表示できるよう、同じくフラッシュにエラーメッセージを保存しておく
。
これにはwithメソッドを利用する。
-----------------
with(key, value)
・key：キー
・value：値
----------------------------------
＊入力フォームの修正
あとは、resultフォームで、用意されたフラッシュデータを表示するだけ。
-----------------
[ctrl/form.blade.php]
@if(session('alert'))
<div class="alert">{{ session('alert') }}</div>
@endif
<form method="POST" action="ctrl/result">
  ...
  <input id="name" name="name" type="text"
    value="{{ old('name', '') }}"/>
  ...
</form>
-----------------
フラッシュ値にアクセスするには、セッションと同じく、sessionメソッドを利用する
。
oldメソッドはLaravel標準ヘルパーで、直前の入力値を返す。
初期値を指定したい場合、引数defaultを指定しておく。
-----------------
old(name[, defualt])
・name：入力項目の名前
・default：既定値
----------------------------------
＊入力値のフラッシュへの保存
正常な表示時にも、元の入力値をテキストボックスに残したい場合、flashメソッドを
利用する。
これで現在のリクエスト情報がフラッシュに保存される。
-----------------
$req->flush();
return view('ctrl.form', [...]);
==================================

Part 8 データベース連携（データの取得）

＠データベース連携
Eloquentは、Laravel標準のO/Rマッパー。
==================================

＠マイグレーション
Laravelでは、データベースのセットアップは、マイグレーションという機能を利用す
るのが一般的。
マイグレーションとは、テーブルレイアウトの定義をスクリプトとして表し、コマンド
ラインから実行するための仕組み。
マイグレー損を利用することで、テーブル保守の作業を半自動化できるだけでなく、レ
イアウトに変更が生じた際にも簡単に反映できる。

＠マイグレーションファイルの作成
[1] マイグレーションファイルを作成する。
テーブルレイアウトを定義するためのマイグレーションファイルを作成する。
コマンドラインから以下のコマンドを実行する。
-----------------
>php artisan make:migration create_books_table
-----------------
「create_xxx_table」はマイグレーションファイルの名前。
「xxx」はテーブルの名前。
コマンドが成功すると、/app/database/migrationsフォルダ配下に、2019_07_09_09554
0_create_books_table.phpのようなマイグレーションファイルが生成される。
----------------------------------
[2] テーブル情報を定義する
自動生成されたマイグレーションファイルを開くと、最低限の骨組みができているので
、編集する。
-----------------
[2019_07_09_}095540_create_books.table.php]
<?php
use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;
class CreateBookstable extends Migration
{
  //a. マイグレーション実行でbooksテーブルを作成
  public function up()
  {
    Schema::create('books', function(Blueprint $table) {
      $table->bigIncremets('id');
      $table->string('isbn');
      $table->string('title');
      $table->string('price');
      $table->string('publisher');
      $table->date('published');
      $table->timestamps();
    });
  }

  //b. ロールバック時にはbooksテーブルを削除
  public function down()
  {
    Schema::dropIfExists('books');
  }
}
-----------------
マイグレーションファイルは、大雑把に、テーブルを生成するためのupメソッドと、削
除するためのdownメソッドとで構成される。
-----------------
upメソッド配下のSchema::createが、テーブル作成するためのメソッド。
Schema::create(name, func)
・name：テーブル名
・func：テーbる生成のための関数
funcは、引数としてBlueprintオブジェクトを受け取る。
Blueprintは、フィールド定義のためのメソッドを提供しており、func配下でもこれを
利用してフィールドを追加していく。
以下は主なメソッド
・integer/bigInteger  整数型
・string/text/longText  文字列型
・float/double  浮動小数点型
・boolean  真偽型
・datetime/date  日付時刻型
・increment  自動連番型
・timestamp  タイムスタンプ（create_at/update_at）
それぞれ生成するべき列名を引数として渡す。
increment/timestampだけが特殊なメソッド。
incrementは、自動連番（AUTO_INCREMTN)なINT型の列を作成する。
timestampは、created_at(生成日）／update_at(更新日)という2個の列を作成する。
create_at/update_atは、いずれもLaravelによって自動設定されるフィールドで、デー
タの作成、更新日を記録する。
一般的に、increment、timestampは最低限すべてのテーブルに含めるべき。
-----------------
downメソッド配下のdropIfExistsメソッドは、指定されたテーブルが存在する場合に削
除する。
----------------------------------
[3] テーブルを削除する
既にquick_laravelデータベースにはbooksテーブルができているので、マイグレーショ
ンを実行する前に削除しておく。
-----------------
mysql> DROP TABLE books;
----------------------------------
[4] マイグレーションを実行する
>php artisan migrate
...
-----------------
確認する。
----------------------------------
mysql> use quick_laravel;
mysql> show tables;
+-----------------+
| Tables_in_quick_larave |
+-----------------+
| books           |
| failed_jobs     |
| migrations      |
| password_resets  |
| users           |
+-----------------+
5 rows in set(0.001 sec)
-----------------
migrationsテーブルは、マイグレーションの実行履歴を管理するためのテーブル。
Laravelは、このテーブルの内容を元に、マイグレーションを実行している。
※実行済みのファイルが繰り返し実行されることはない。
その他の、users/password_resets/failed_jobsは、Laravel標準で用意された認証やジ
ョブ管理のためのテーブル。
----------------------------------
＊マイグレーションコマンド
マイグレーションは、テーブルを作成する（＝前に進める）だけではない。
・migrate:rollback
最後に実行したマイグレーションをロールバック
・migrate:rollback --step=5
過去5回分のマイグレーションをロールバック
・migrate:reset
すべてのマイグレーションをロールバック
・migrate:refresh
すべてのマイグレーションをロールバックしたうえで、再度マイグレーションを実行
・migrate:refresh --seed
すべてのマイグレーションをロールバックしたうえで、再度マイグレーションを実行（
シードを投入）
==================================

＠Schemaクラス／Blueprintクラスのメソッド
Schemaクスには、create、dropIfExistsメソッドの他にも、以下のようなメソッドが用
意されている。
・drop(name)
無条件にテーブルを削除（存在しない場合はエラー）
・rename(old, new)
テーブル名をリネーム
・table(name, func)
funcの内容でテーブル列を更新
----------------------------------
テーブル生成関数（引数func）の引数（Blueprintクラス）でも列の追加のためのメソ
ッドの他、以下のようなメソッドが用意されている。
・renameColumn(old, new)
列名をold→newに変更
・dropColumn(name)
列を削除
・unique(name)
インデクスを作成
また、列追加の際に利用できる修飾メソッドもある。
・before(name)
指定列の直前に追加
・after(name)
指定列の直後に追加
・autoIncrement()
現在の列を自動連番に。
・nullable()
列のNULL値を許容
・default(value)
既定値を設定
修飾メソッドは以下のように利用する。
-----------------
$table->string('title')->nullable()
-----------------
これらのメソッドを利用することで、より複雑なマイグレーションを表現可能。
==================================

＠シーダー
一般的にはアプリの動作を確認するためにテストデータ／初期データが必要となる。
これを行うのがシーダー（seeder）。
----------------------------------
[1] シーダーを作成する
以下のコマンドで骨組みを自動生成できる。
-----------------
>php artican make:seeder BooksTableSeeder
-----------------
「BooksTableSeeder」の「Books」は、テーブル名に応じて置き換えること。
----------------------------------
[2] シーダーを編集する
シーダーは、/database/seedsフォルダに生成される。
以下のように編集する。
-----------------
[BooksTableSeeder.php]
<?php
use Illuminate\Database\Seeder;
class BooksTableSeeder extends Seeder
{
  public function run()
  {
    DB::insert('INSERT INTO books(isbn, title, price, publisher, published) 
      VALUES ("978-4-822-5399-8", "Visual C# 2019超入門", 2000, "日経BP", 
      "2019-08-22")');
    ...
  }
}
-----------------
シーダーで実装すべきはrunメソッドだけ。
データ投入のためのコードを追加する。
ここではDB::insertメソッドを利用しているが、Eloquentを利用してもよい。
----------------------------------
[3] シーダーを登録する
シーダーはそのままで実行できない。
対象のシーダーをアプリに登録しておく必要がある。
/app/database/seedsフォルダ配下にDatabaseSeeder.phpというファイルがあるので、
以下のように編集する。
-----------------
[DatabaseSeeder.php]
<?php
use Illuminate\Database\Seeder;
class DatabaseSeeder extends Seeder
{
  public function run()
  {
    $this->call(BoooksTableSeeder::class);
  }
}
-----------------
callメソッドに実行すべきクラスを渡すだけ。
「::class」は、指定されたクラスの完全修飾名を取得する。
複数のシーダーを登録するなら、callメソッドを必要な数だけ呼び出す。
----------------------------------
[4] シーダーを実行する
以下のコマンドで実行できる
-----------------
> php artisan db:seed
-----------------
上記はすべてのシーダーをまとめて実行するが、個別のシーダーを実行する場合以下の
コマンドも利用できる。
-----------------
> php artisan db:seed --class=BooksTableSeeder
-----------------
データベースを完全初期化するならば、以下のコマンドを利用する。
全てのマイグレーションをロールバック＆再実行し、シードを投入できる。
-----------------
> php artisan migrate:refresh --seed
==================================

'978-4-8222-5399-8','Visual C# 2019超入門',2000,'日経BP','2019-08-22'
'978-4-7980-5759-0','はじめてのAndroidアプリ開発',3200,'秀和システム','2019-08-10'
'978-4-7981-5112-0','独習Java 新版',2980,'翔泳社','2019-05-15'
'978-4-7741-9763-0','3ステップでしっかり学ぶ Python',2480,'技術評論社','2018-05-24'
'978-4-7741-9617-6','Swiftポケットリファレンス',2880,'技術評論社','2018-03-09'
'978-4-7981-5382-7','独習C# 新版',3600,'翔泳社','2017-12-15'
'978-4-295-00409-7','これから学ぶJavaScript',2400,'インプレス','2018-07-20'
'978-4-295-00638-1','これから学ぶHTML/CSS',2400,'インプレス','2019-06-21'
'978-4-7981-5757-3','JavaScript逆引きレシピ',2800,'翔泳社','2018-10-15'

＠データの取得
all()メソッドは、いわゆる「SELECt * FROM table」に相当する、最も基本的なデータ
取得の手段。
==================================

＠主キーで検索
findメソッドを利用することで、主キーでデータを検索できる。
以下は「id=1」の書籍情報を取得する例。
-----------------
[RecordController.php]
public function find()
{
  return Book::find(1)->title;
}
----------------
Eloquent経由で取得したデータは、モデルオブジェクト（もしくはその配列）。
「->title」は、取得したレコードのtitleフィールドを取得、という意味
----------------------------------
＊主キーを変更する
Eloquentでは、既定でid列（INT型、AUTO_INCREMENT）を主キーとみなす。
この挙動を変更するには、モデルクラスに以下を追加する。
-----------------
class Book extends Model
{
  protected $primaryKey = 'isbn'; // 列名
  protected $keyType = 'string'; // データ型
  public $incrementing = false; // 自動連番
}
==================================

＠任意の列でデータを検索する
主キー以外の列をキーに、テーブルを検索することもできる。
whereメソッドを使う。
-----------------
[RecordController.php]
public function where()
{
  $result = Book::where('publisher', '翔泳社')->get();
  return view('hello.list', ['records'=>result]);
}
-----------------
whereメソッドには、「列名」「検索値」を渡す。
whereメソッドの戻り値は、検索条件を組み立てるためのBuilderクラス。
最終的な結果を得るには、getメソッドを呼び出す。
getメソッドをfirsメソッドに置き換えた場合、最初の1件だけを取得できる。
-----------------
$result = Book::where('publisher', '翔泳社')->first();
return $result->title;
==================================

＠whereメソッドによるさまざまな検索
whereは汎用的なメソッドで、引数に渡す条件次第で、さまざまな検索が可能。
----------------------------------
(1)大小比較
whereメソッドには、「列名」「演算子」「検索値」を渡すことができる。
-----------------
$result = Book::where('price', '<', 3000)->get();
----------------------------------
(2)部分一致検索
部分一致検索（LIKE）も可能。
-----------------
$result = Book::where('title', 'LINE', '%Java%')->get();
----------------------------------
(3)範囲検索
INで検索する際にはwhereInメソッドを利用する。
第2引数には、候補値を配列として渡す。
-----------------
$result = Book:whreIn('publisher', ['日経BP', '翔泳社', 'インプレス'])->get();
-----------------
同じくBETWEEN検索のwhereBetweenメソッドもある。
-----------------
$result = Book:whereBetween('price', [1000, 3000])->get();
-----------------
どちらも、NOT条件を表すwhereNotIn, whereNotBetweenメソッドが用意されている。
----------------------------------
(4)NULLチェック
NULLであるかを判定するには、whereNull/whereNotNullメソッドを使う。
-----------------
$result = Book::whereNull('publisher')->get();
----------------------------------
(5)日付検索
whereDate, whereYear, whereMonth, whereDay, whereTimeメソッドを使う。
日付、年月日、時刻と、検索値に応じて使い分ける。
-----------------
$result = Book::whereYear('publsihed', '2019')->get();
-----------------
whereメソッドと同じく、演算子指定も可能。
-----------------
$result = Book::whereYear('publisher', '<', '2019')->get();
----------------------------------
(6)AND/OR条件
whereメソッドを複数呼び出した場合、条件式はAND演算子で接続される。
-----------------
$result = where('publisher', '翔泳社')->where('price', '<', 3000)->get();
-----------------
OR検索する場合は、orWhereメソッドを使う。
-----------------
$result = where('publisher', '翔泳社')->orWhere('price', '<', 2500)->get();
----------------------------------
(7)生の条件式
WHERE句が複雑になってくると、生の条件式で表した方が楽な場合もある。
それにはwhereRawメソッドを使う。
-----------------
$result = Book::whereRow('publisher=? AND price<?', ['翔泳社', 3000])->get();
-----------------
条件式の「?」はプレイスホルダ。
プレイスホルダには、第2引数の配列値が順に埋め込まれる。
==================================

＠SELECT命令その他の句
一般的なSELECT命令で利用できる様々な句に対応している。
----------------------------------
＊データの並び替え
orderByメソッドを使う。
引数は「ソート列」「並び順（asc/desc）」。
複数のソートキーがある場合、orderByメソッドを列挙する。
-----------------
$result = Book::orderBy('price', 'desc')->orderBy('published', 'asc')->get();
----------------------------------
＊取得範囲の指定
offset/limitメソッドを利用することで、m～n件目のデータを取り出せる。
-----------------
$result = Book::orderBy('publisher', 'desc')
  ->offset(2)->limit(3)->get();
-----------------
一般的には、データが整列していないと意味がないので、orderByメソッドと組み合わ
せて利用するのが一般的。
----------------------------------
＊取得列の制約
selectメソッドを利用することで、取得列を制限できる。
selectメソッドを明示しなかった場合、すべての列を無条件に取得する。
-----------------
$result = Book::select('title', 'publisher')->get();
----------------------------------
＊データのグループ化
groupByメソッドを使う。
-----------------
$result = Book::groupBy('publisher')
  ->selectRow('publichser, AVG(price AS price_avg')->get();
-----------------
selectRowメソッドは、whereRowメソッドのselect版。
取得列を生の式で表す。
取得列に集計関数／別名などが含まれる場合に利用する。
----------------------------------
＊グループ化列の絞り込み
havingメソッドを使う。
構文はwhereメソッドに順ずる。
-----------------
$result = Book::groupBy('publisher')
  ->having('price_avg', '<', 2500)
  ->selectRow('publisher, AVG(price) AS price_avg')->get();
----------------------------------
＊データの集計
よりシンプルな集計であれば、avg/count/max/minメソッドを使ってもよい。
-----------------
$result = Book::where('publisher', '翔泳社')->max('price');
-----------------
集計メソッドは、そのまま集計値を返すので、get/firstメソッドなどは不要。
----------------------------------
＊生のSQL命令を発行する

### 2巡目 ###

Part 3 : Laravelの基本

3.1 コントローラーの基本
Laravelアプリで、まず処理の起点となるのがControllerクラス。
個々のリクエストを受取り、ビジネスロジックを呼び出し、その結果をビューに反映さ
せる、処理の司令塔。

3.1.1 コントローラーから文字列を出力する
[1] コントローラーを作成する。

>php artisan make:controller HelloController
...

コントローラーの名前は任意だが、一般的にはXxxxxControllerのように、Controller
を接尾辞に付ける。
成功した場合、/app/Http/Controllersフォルダ配下にHelloController.phpが生成され
ている。

[2]コントローラークラスを編集する。

// HelloController.php
<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;

class HelloController extends Controller
{
  public functon index()
  {
    return 'こんにちは、世界！';
  }    
}

a.Controllerクラスを継承する
Controllerクラス（App\Http\Controllers名前空間）は、コントローラーとしての基本
的な機能を提供する。

b.リクエストを処理するのはアクションメソッドの役割
クライアントのリクエストを処理するのは、コントローラークラスで定義されたpublic
メソッド。
これをアクションクラストいう。
一つ以上のアクションメソッドを束ねたものがコントローラー。

c.アクションメソッドの戻り値が出力に
アクションメソッドには、リクエストを受けて、モデル（ビジネスロジック）呼び出し
たり、ビュー（画面）の生成のための準備など、さまざまな役割があるが、最もシンプ
ルなのが、文字列を出力するもの。

アクションメソッドで、戻り値を文字列として返すことで、そのままブラウザへの出力
となる。

[3]ルーティング情報を定義する
ルーティングとは、リクエストURLに応じて処理の受け渡し先を決定すること。
Laravelでは、クライアントからの要求を受け取ると、ルーティング機能を利用して呼
び出すべきコントローラー（アクション）を決定する。
ルーティング機能を提供するライブラリのことをルーターという。

ルーティング設定は、/routes/web.phpに定義する。
既定では/に対するルートが用意されているので、その後方に新たなルートを追加する
。
/ルートは、トップページを表示するものなので、削除してはいけない。

//web.php
// / に対するルート
Route::get('/', function(){...});

// /helloに対するルート
Route::get('/hello', '\App\Http\Controllers\HelloController@index');


ルートの定義（getメソッド）
Route::get(path, action)
path：リクエストパス
action：実行すべきアクション

actionは、「コントローラー名@アクション名」で指定。

[4]サンプルの実行
http://localhost:8000/hello/

＠getメソッドの異なる記法
Route::getメソッドは、コントローラ名は完全修飾名で指定するのが基本。
ただし、ルート定義が増えてきた場合、すべてに完全修飾名を記述するのは手間。
以下のように表すこともできる。
----------------------------------
(1)配列構文で定義する
getメソッドの第2引数を文字列ではなく、[クラス、アクション名]の配列で指定する。
これで、名前空間をuse命令に追い出すことができる。
-----------------
use App\Http\Contollers\HelloController;
...
Rouge:get('/hello', [HelloController::class, 'index']);
----------------------------------
(2)既定の名前空間を登録する
アプリ全体で、コントローラーが属する名前空間を登録することもできる。
-----------------
# /app/Providers/RouteServiceProvider.php
class RouteSreviceProvider extends ServiceProvider
{
  protetected $namespace = 'App\Http\Contollers';
  ...
  public function boot()
  {
    ...
    $this->routes(function() {
    ...
    Route:midlleware('web')
     ->namespace($this->namespace)
     ->group(base_path('routes/web.php'));
  });     
  ...
}
-----------------
名前空間そのものを変更するならば、protectedプロパティ（$namespace）の値を適宜
変更する。
==================================

3.2 ビューの基本
＠ビューの基本
コントローラーから直接出力を生成できるが、Model-View-Controllerの考え方に沿っ
ていない。
最終的な出力は、Bladeテンプレートを利用するのが基本。
-----------------
Bladeテンプレートは、HTMLにPHPスクリプトを埋め込むための仕組み。
HTMLがベースとなるため、最終的な出力をイメージしながら、レイアウトを進められる
メリットがある。
----------------------------------
(1)アクションを追加する
# HelloController.php
class HelloController extends Controller
{
  ...
  public function view()
  {
    // a. ビューを準備
    $data = [
      'msg' => 'こんにちは、世界！'
    ];
    // b. テンプレートを呼び出す。
    return view(''hello.view', $data);
  }    
}
-----------------
a. ビュー変数を用意する
ビュー変数とは、テンプレートに埋め込む値のこと。
Bladeを利用する場合、アクション側で表示に必要なデータを用意しておき、テンプレ
ートではデータを埋め込む場所や表示方法などを定義する、という役割分担が基本。
-----------------
ビュー変数は、「名前=>値」形式の連想配列として準備する。
列挙することで、複数のビュー変数を用意することもでき、値にも文字列だけでなく、
数値・配列などの任意のオブジェクトを指定できる。
-----------------
b. テンプレートの呼び出し
テンプレートを呼び出すのは、viewメソッドの役割
-----------------
viewメソッド
view(path, args)
path：テンプレートのパスワード
args：ビュー変数（連想配列）
-----------------
引数pathには、「フォルダ名.ファイル名」の形式で、呼び出すテンプレートを指定す
る。
・区切り文字は「.」
・ファイル名は、ベース名（拡張子を除いた名前）
この例では、hello.viewとしているので、/hello/view.blade.phpというテンプレート
を示す。
----------------------------------
(2)テンプレートを準備する
テンプレートファイルは、/resources/viewsフォルダ配下に「コントローラー/アクシ
ョン名.blade.php」として配置するのが一般的。
これにより、コントローラー／アクションとの対応関係が明らかになる。
コントローラー名は、接尾辞のControllerを除いて表す。
-----------------
この例であれは、HellController＠viewアクションに対応するテンプレートなので、he
llo/view.blade.phpとなる。
-----------------
# hello/view.blade.php
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>速習Laravel</title>
</head>
<body>
{{ $msg }}
</body>
</html>
----------------------------------
ルート定義を追加
-----------------
# /routes/web.php
...
  Route::get('/hello/view', [HelloContoller::class, 'view');
----------------------------------
http::127.0.0.1/hello/viewでアクセス。
==================================

＠テンプレートの事前コンパイル
テンプレートは以下の手順を経て実行される。
・コンパイル（=PHPに変換）済のテンプレートが存在するか判定
・存在する場合は、オリジナルのビューがコンパイル以降に変更されていないかを判定
・コンパイル済みのテンプレートが存在しない、もしくはコンパイル版テンプレートが
古くなっている場合は（再）コンパイル
・テンプレートを実行
アプリの実行前に、上記手順を済ませておきたい場合は、以下のコマンドを実行する。
> php artisan view:cache
コンパイル結果が/storage/framework/viewsフォルダに生成される。
コンパイル済みテンプレートをまとめて削除する場合、以下のコマンドを実行する。
> php artisan view:clear
==================================

3.3 モデルの基本
＠モデルの基本
Model（モデルとは、データベース／外部サービスへのアクセスを始め、ビジネスロジ
ックを担うコンポーネントのこと。
アプリの心臓部。
Laravelでは、データベースへのアクセス手段として、いくつかのアプローチを提供し
ているが、Laravel標準で提供されているO/RマッパーはEloquent。
==================================

＠Eloquantとは
Eloquantとは、データベースとアプリのモデルクラス（オブジェクト）形式のデータを
受け渡しする、O/R（Object/Relational）マッパーの一種。
O/Rマッパーをりようすることで、ひとつのフィールド（列）を、ひとつのプロパティ
に自動的に割り当てられるので、データベースから取得した結果をオブジェクトに詰め
替えるような手間が省ける。
オブジェクトの内容をデータベースに反映させる場合も同様。
オブジェクト操作の一環として、データベースを操作できるようになる。
==================================

＠データベース利用の準備
(1)データベースを作成する
>mysql -u root -p
Enter password:
>CREATE DATABASE quick_laravel CHARCTER SET utf8;
...
>GRANT ALL PRIVILEGETS ON quick_laravel.* TO quickusr@localhost IDENTIFED BY 
'quickpass';
...
>USE quick_laravel;
...
>source c:\quick.sql;
...
>exit;
-----------------
データベースには、任意のテーブル／フィールドを定義できるが、以下のルールに従う
こと。
・テーブル名は名詞の複数形
・主キーはid（INT型、シリアル値）
----------------------------------
(2)データベース接続定義ファイルを編集する
Laravelからデータベースに接続するには、/configフォルダ配下の設定ファイルdataba
se.phpを編集する。
-----------------
// database.php
<?php
use Illuminate\Support\Str;
return [
  //c. 既定の接続
  'default' => env('DB_CONNECTION', 'mysql'),
  'connection' => [
    'sqlite' => [...],
    'mysql' => [
      'driver' => 'mysql',
      'url' => env('DATABASE_URL'),
      'host' => env('DB_HOST', '127.0.0.1'),
      'port' => env('DB_PORT', '3306'),
      'database' => env('DB_DATABSE', ''quick_laravel'),
      'username' => env('DB_USERNAME', 'quickusr'),
      'password' => env('DB_PASSWORD', 'quickpass'),
      'unix_socket' => Senv('DB_SOCKET', ''),
      'charset' => 'utf8mb4',
      'collation' => 'utf8mb4_unicode_ci',
      ...
    ],
    'pgsql' => [...],
    'sqlsrv' => [...],
  ],
];
-----------------
collectionキーの配下にデータベースごとの設定がまとめられている。
上からsqlite、mysql(MySQL/MaribDB)、pgsql(PostgreSQL)、sqlsrv(SQLServer)。
作成したデータベースの情報を設定ファイルに反映させる。
・database：データベース名
・username：接続時のユーザ名
・password：接続時のパスワード
設定できる項目は、データベースによって異なるが、他のデータベースでも、最低限こ
れらを設定する。
唯一、SQLiteだけは、username/passwordは不要で、databaseキーには、データベース
名の代わりに、データベースのファイル名（sample.sqliteなど）を設定する。
あとは、defaultキーに接続先のデータベースを指定するだけ。
既定はmysqlなので、そのままにしておく。
----------------------------------
(3)Laravel環境変数を定義する
最後にLaravelの動作時に利用する環境変数ファイルを編集。
アプリルート配下に、.envファイルが用意されているので、以下の箇所に、データベー
ス情報を反映させる。
-----------------
// .env
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=quick_laravel
DB_USERNAME=quickusr
DB_PASSWORD=quickpass
-----------------
開発サーバの場合、データベースの設定を負えたら再起動する。
----------------------------------
＊env関数の意味
たとえば「env('DB_HOST', '127.0.0.1')」は、環境変数DB_HOSTから値を取得し、存在
しない場合は既定値として「127.0.0.1」を使う、という意味。
環境変数として、.envを切り分けているのは、開発環境と本番環境とで設定情報の差し
替えを簡単にするため。
.envに環境依存の情報を切り出すことで、移行する際にも、個々の設定ファイルを書き
換える必要がなくなる。
本番環境用の.envを用意して、.envだけを差し替えるのが基本
==================================

＠モデルクラスの作成
データベースにアクセスするためのモデルクラスを作成する。
以下のコマンドを使う。
-----------------
>php artisan make:model Book
-----------------
モデルクラスは、テーブル名（複数形のbooks）に対して、単数形（Book）とする。
これによりモデルとテーブルが紐づく。
成功した場合、/app/Modelsフォルダにモデルクラスができている。
-----------------
/* app/model/Book.php */
<?php
namespace App/Models;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Mode;
// Modelクラスを継承
class Book extends Model
{
  use HasFactory;
}
==================================

＠データアクセスの基本
Eloquentの動作確認のため、テーブルbooksの情報を一覧表示させる。
----------------------------------
(1)アクションメソッドを追加する
-----------------
/* app/Http/Controllers/HelloController.php
// モデルクラスをインポート
use App\Models\Book;
class HelloController extends Controller
{
  ...
  public function list()
  {
    $data = [
      'records'=>Book::all(),
    ];
    return view('hello.list', $data);
  }
}
-----------------
テーブルからすべてのレコードを無条件に取得するには、作成済みのモデル（Bookモデ
ル）のallメソッドを呼び出す。
allは、「SELECT * FROM books」と同じ。
結果をCollectionオブジェクト（モデルの集合）として返す。
これをテンプレート側から呼び出せるよう、ビュー変数に格納しておく。
----------------------------------
(2)テンプレートファイルを作成する
/* resources/views/hello/list.blade.php */
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>速習Laravel</title>
<link rel="stylesheet" href="https://csn.jsdeilvr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css">
</head>
<body>
<table class="table">
<tr>
  <th>署名</th>
  <th>価格</th>
  <th>出版社</th>
  <th>刊行日</th>
</tr>
@foreach ($records as $record)
<tr>
  <td>{{ $record->title }}</td>
  <td>{{ $record->price }}</td>
  <td>{{ $record->publisher }}</td>
  <td>{{ $record->published }}</td>
</tr>
@endforeach
</table>
</body>
</html>
-----------------
Collectionのような配列ライクなオブジェクトを順に処理するのは、@foreachディレク
ティブの役割。
ディレクティブとは、Bladeテンプレートの中で利用できる命令のこと。
条件分岐、ループ、そのほかの基本的制御構文が用意されており、@...の形式で表すの
が基本。
-----------------
@foreachディレクティブ
@foreach(list as var)
  ...contents...
@endforeach
list：繰り返し対象の配列
var：仮引数
contents：繰り返すべき内容
-----------------
構文そのものは、PHP標準のforeach命令とほぼ同じ。
$recordsから順にモデルを取り出し、内容を出力。
@foreachブロックの中では、「仮引数->フィールド名」の形式で、個々のフィールド値
にアクセスできる。
----------------------------------
(3)サンプルを実行する
/* routes/web.php */
Route::get('/hello/list', [HelloController::class, 'list']);
-----------------
「http://127.0.0.1/hello/list」で、一覧が表示される。

＠HTMLエスケープの無効化 {!!...!!}
HTMLエスケープとは、HTMLの予約語である<, >, &などの予約文字を、&lt; &gt; &amp;
のような無害な文字列に置き換えること。
外部から取得した値を出力する上で、エスケープ処理は欠かせない。
エスケープ処理の漏れは、そのままクロスサイトスクリプティング（XSS）と呼ばれる
脆弱性に繋がる。
----------------------------------
ただし、Laravelを利用する上で、エスケープを意識することはあまりない。
{{...}}では、式の値を暗黙的にエスケープした上で出力するから。
しかし、時として、動的にHTMLを生成し、ページに反映させたいケースもある。
これには、{!!..!!}構文を利用する。
-----------------
/* ViewController.php */
public function escape()
{
  return view('view.escape', [
    'msg'=>'img/src="https://wings.msn.to/image/wings.jpg" title="ロゴ">
    <p>WINGSへようこそ</p>'
  ]);
}
-----------------
/* view/escape.blade.php */
{!! $msg !!}
-----------------
これによりタグが正しく解釈される。
{{ $msg }}に変更すると、タグがそのまま表示される。
----------------------------------
＊{!!...!!}は信頼できるコンテンツにだけ利用する
任意のコンテンツを{!!...!!}で埋め込むのは、深刻な脆弱性の原因となる可能性があ
る。
信頼できる（適切なエスケープ処理が行われていることがわかっている）コンテンツに
対してのみ利用すべき。
==================================

＠{{...}}の無効化  @構文
{{...}}をPHPの式ではなく、そのまま文字列として表示したい（＝式を無効化したい）
場合は、{{...}}の前に@を付与する。
-----------------
<p>@{{ $msg }}</p>
-----------------
無効化したい{{...}}が複数ある場合は、@verbatim...@endverbatimで該当のコードを
括ることもできる。
-----------------
@verbatim
<p>{{ $msg }}</p>
@endverbatim
-----------------
@{{...}}ではなく、{{...}}としているのに、無効化されている。
大量の{{...}}を無効化するには便利。
==================================

＠テンプレートにコメントを残す
Bladeテンプレートの基盤はHTMLなので、<!-- -->は使える。
ただし、<!-- -->はブラウザ画面から見えないだけで、クライアントには送信される。
-----------------
クライアントに送信されないコメントを表すには、Bladeのコメント構文{{--...--}}を
利用する。
-----------------
/* view/comment.blade.php */
{{--
これはコメントです。
クライアントには、送信されません。
--}}
==================================

＠共通のビュー変数を準備する
アプリ開発では、ほとんどのビューで利用したい共通の情報が必要となる場合がある。
その場合、アクションでビュー変数を定義する代わりに、/app/Providers/AppServiceP
rovider.phpを編集する。
/* app/Providers/AppServiceProvider.php */
use Iluminate\Support\Facades\View;
...
public function boot()
{
  View::share('appTitle', '速習Laravel');
}
==================================

＠基本ディレクティブ
ディレクティブとは、@～で始まる特別な命令のこと。
Laravelに何らかの指示を渡すための仕組み。
@foreachの他にも、テンプレートで利用できるディレクティブを豊富に用意している。
==================================

＠汎用的な条件分岐を表す  @if
条件式の正否に応じて出力を決めるのが、@if...@endifディレクティブ。
-----------------
/* app/Http/Controllers/ViewController.php */
public function if()
{
  return view('view.if', [
    'random'=>random_int(0, 100)
  ]);
}
-----------------
/* resources/views/if.blade.php */
@if($random < 50)
<p>{{ $random }}は50未満です。</p>
@else
<p>{{ $random }}は50以上です。</p>
@endif
-----------------
三分岐以上を表現したい場合は、@elseifディレクティブも利用できる。
-----------------
/* resources/views/if.blade.php */
@if ($random < 50)
<p>{{ $random }}は50未満です。</p>
@elseif ($random < 70)
<p>{{ $random }}は50以上70未満です。</p>
@else
<p>{{ $random }}は70以上です。</p>
@endif
----------------------------------
＊環境によって出力を切り換える
@envディレクティブを利用することで、アプリが特定の環境で動作している場合だけ、
特定のコンテンツを表示することもできる。
環境判定に特化した@ifといえる。
-----------------
@env('local')
// local環境だけで表示されるコンテンツ
@endenv
-----------------
/* .env */
APP_NAME=Laravel
APP_ENV=local
==================================

＠否定の条件分岐を表現する @unless
条件式がfalseの場合に出力する@unlessも用意されている。
-----------------
@unless ($random === 50)
  <p>{{ $random }}は、50ではありません!</p>
@endunless
-----------------
@unlessでも、@elseは使えるが、否定の否定はコードが読みにくくなるので推奨されな
い。
==================================

＠変数の有無によって表示を振り分ける  @isset/@empty
@ifの特殊な形態として、変数の有無、またはnullでないかどうかによって表示を振り
分ける@isset/@emptyディレクティブがある。
@issetの例。
-----------------
/* app/Http/Controllers/ViewController.php */
public function isset()
{
  return view('view.isset', [
    'msg'=>'こんにちは、世界！';
  ]);
}
-----------------
/* resources/views/view/iseet.blade.php */
@isset($msg)
<p>変数msgは「{{ $msg }}」です。</p>
@endisset
----------------------------------
変数が存在しない場合にだけ表示したい場合、@emptyを利用する。
-----------------
/* resources/views/view/isset.blade.php */
@empty($msg)
<p>メッセージがありません。</p>
@endempty
-----------------
@isset、@emptyともに、@else句を持つことも可能。
==================================

＠等価比較による条件分岐  @switch
式の値に応じて表示を振り分けるならば、@switchディレクティブを利用する。
-----------------
/* app/Http/Controllers/ViewController.php */
public function switch()
{
  return view('view.switch', [
    'random'=>random_int(1,5),
  ]);
}
-----------------
/* resources/views/view/switch.blade.php */
@switch($random)
  @case(5)
    <p>大ラッキーの一日です！</p>
    @break
  @case(4)
    <p>ちょっぴりいいことがあるかも？</p>
    @break
  @case(3)
    <p>ふつーの一日です。</p>
    @break
  @case(2)
    <p>今日は静かに過ごしましょう。</p>
    @break
  @default
    <p>umm...</p>
@endswitch
-----------------
ディレクティブになっただけで、構文そのものはPHP標準のswitchと同じ。
@case句の終わりは@breakで終える、すべての@caseに合致しなかった場合@defaultの内
容が表示される。
==================================

＠条件式によって出力を繰り返す  @while
@whileディレクティブは、条件式がtrueの間だけループする。
基本的だが、あまり使用しない。
終了条件を満たすには、ループ内での処理が必要となり、また、大概の場合、@foreach
/@forでシンプルに書けるので。
-----------------
/* resources/views/view/while.blade.php */
<!-- 変数の初期化 -->
@php
$i = 0;
@endphp
@while($i < 6)
  @php
    $i++;
  @endphp
  <h{{ $i }}>{{ $i }}番目です。</h{{ $i }}>
@endwhile
==================================

＠指定された回数だけ処理を繰り返す  @for
@forディレクティブは、PHP標準のforに相当する。
-----------------
/* resoruces/views/view/for.blade.php */
@for($i=1;$i<=6;$i++)
<h{{ $i }}>{{ $i }}番目です。</h{{ $i }}>
@endfor
-----------------
カウンター変数に基づいてループするなら、@forがシンプル。
@phpディレクティブも要らない。
==================================

＠配列の内容を順番に出力する  @foreach
----------------------------------
＊インデックス番号を取り出す
PHP標準のforeach命令に順ずるので、インデクス番号/値の双方を仮引数として受け取
ることもできる。
-----------------
/* resources/views/hello/list.blade.php */
<table class="table">
<tr>
....
</tr>
@foreach($records as $id=>$record)
<tr>
  <td>{{ $id + 1 }}</td>
  ...
</tr>
@endforeach
----------------------------------
＊連想配列を処理する
@foreachでは、連想配列も処理できる。
-----------------
/* app/Http/Controllers/ViewController.php */
public function foreach_assoc()
{
  return view('view.foreach_assoc', [
    'member'=>[
      'name'=>'YAMADA, Yoshihiro',
      'sex'=>'男',
      'birth'=>'1923-11-10',
    ]
  ]);
}
-----------------
/* resources/views/view/foreach_assoc.blade.php */
@foreach($members as $key=>$value)
  <li>{{ $key }}：{{ $value }}</li>
@endforeach
----------------------------------
＊ループ変数を参照する
ループの配下では、$loopという特殊な変数にアクセスできる。
$loopは、ループ変数と呼ばれ、ループに関するさまざまな情報を持っている。
-----------------
index
インデクス番号（0スタート）
iteration
繰り返し数（1スタート）
remaining
残っている要素数
count
配列の総数
first
最初の項目か
last
最後の項目か
even
偶数回目か
odd
奇数回目か
depth
入れ子レベル
parent
親のループ変数（ネストした場合）
-----------------
/* app/Http/Controllers/ViewController.php */
public function foreach_loop()
{
  return view('view.foreach_loop', [
    'weeks'=>['月', '火', '水', '木', '金', '土', '日']
  ]);
}
-----------------
/* resources/views/view/foreach_loop.blade.php */
<table class="table">
<tr>
  <th>値</th>
  <th>index</th>
  <th>iteration</th>
  <th>count</th>
  <th>first</th>
  <th>last</th>
  <th>even</th>
  <th>odd</th>
  <th>depth</th>
</tr>
@foreach($weeks as $week)
<tr>
  <td>{{ $week }}</td>
  <td>{{ $loop->index }}</td>
  <td>{{ $loop->iteration ]}</td>
  <td>{{ $loop->count }}</td>
  <td>{{ $loop->first }}</td>
  <td>{{ $loop->last }}</td>
  <td>{{ $loop->even }}</td>
  <td>{{ $loop->odd }}</td>
  <td>{{ $loop->depth }}</td>
</tr>
@endforeach
==================================

＠配列が空の場合の出力を決める  @forelse
@foreachディレクティブの変形形として、@forelseディレクティブもある。
@forelseの用法はほぼ@foreachと同じだが、配下に@empty句を置ける点が異なる。
-----------------
/* resources/views/view/forelse.blade.php */
@forelse($records as $record)
<tr>
...
</tr>
@empty
<p>データは存在しません。</p>
@endforelse
-----------------
これで、配列（この例では$records)が空の場合は、その旨がメッセージ表示されるよ
うになる。
データの有無によって表示を振り分ける場合、@ifディレクティブを利用するより、@fo
relseディレクティブの利用がおすすめ。
==================================

＠ループを即座に脱出する  @break
@breakディレクティブを利用することで、即座にループを終了できる。
例えば、以下はforeach_loop.blade.phpを修正して、ループ変数のiterationプロパテ
ィが3を超えたところで、ループを終了する。
-----------------
/* resources/views/view/foreach_loop.blade.php */
@foreach($weeks as $week)
  @break($loop->iteration>3)
  <tr>
  ...
  </tr>
@endforeach
-----------------
@breakディレクティブの引数には、ループの終了条件を表す。
条件式を省略した場合、無条件にループは終了する。
==================================

＠現在の周回をスキップする  @continue
@continueディレクティブは、現在の周回を終了し、次の周回にスキップする。
-----------------
/* resources/views/view/foreach_loop.blade.php */
@foreach($weeks as $week)
  @contine($loop->odd)
  <tr>
  ...
  </tr>
@endforeach
-----------------
偶数回の周回を表示するので、奇数回目の周回をスキップしている。
==================================

＠スタイルクラスを動的に設定する  @class
@classディレクティブを利用することで、class属性（スタイルクラス）を設定できる
。
-----------------
/* app/Http/Controllers/ViewController.php */
public function style_class()
{
  return view('view.style_class', [
    'isEnabled'=>true
  ]);
}
-----------------
/* resources/views/view/style_class.blade.php */
<div @class([
  'colun',
  'notice'=>$isEnabled,
  'example'=>!$isEnabled,
])>
classディレクティブ
</div>
-----------------
/* 結果 */
<div class="column notice">
classディレクティブ
</div>
-----------------
@classディレクティブには、[クラス名=>true/false,...]形式の配列を渡すのが基本。
trueが渡されたスタイルクラスだけが有効になる。
無条件にスタイルを有効にしたい場合、単にクラス名を列挙する。
==================================

＠ラジオボタン／チェックボックス／選択ボックスの選択状態を決める　@checked/@selected
@checked, @selectedディレクティブを用いることで、ラジオボタン／チェックボック
ス／選択ボックスのchecked, selected属性を動的に設定できる。
-----------------
/* app/Http/Controllers/ViewController.php */
public function checked()
{
  return view('view.checked', [
    'isEnabled'=>true
  ]);
}
-----------------
@checkedディレクティブは、引数がtrueの場合にだけ、チェックを有効にする。
一般には、データベースの値、以前の入力値などを反映させる。
----------------------------------
@selectedディレクティブの場合も<option>要素に渡すほかは、構文は同じ。
----------------------------------
＊@disabledディレクティブ
@checked/@selectedディレクティブと同じく、引数の真偽に応じて属性の出力を決める
ディレクティブとして@disabledディレクティブがある。
@disabledディレクティブは、その要素を無効状態にする。
==================================

＠任意のコードを実行する @php
@phpディレクティブを利用することで、テンプレートに任意のコードを埋め込める。
基本的に@phpの利用は例外的と考えること。
テンプレートに混在するコードは、テンプレートの見通しを悪くする。
@phpが現れる状況では、そのコードがアクション／モデルで表せないかを検討すること
。
----------------------------------
＊Bladeを利用しない選択肢
そもそもBladeに頼らず、標準的な<?php ... ?>だけでテンプレートを表すことも可能
。
-----------------
/* resources/views/hello/view.php */
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>速習Laravel</title>
</head>
<?php print($msg); ?>
</body>
</html>
-----------------
このサンプルを確認するには、Bladeのテンプレート（resources/views/hello/view.bl
ade.php）をあらかじめ対比させること。
同名のテンプレートがある場合、.blade.phpが優先されるので。
==================================

4.3 レイアウト

＠レイアウトとは
レイアウト（レイアウトテンプレート）とは、いわゆるサイトデザインの外枠。
あらかじめ見た目の共通部分（ヘッダやフッタなど）をレイアウトとしてまとめておく
ことで、個々のテンプレートファイルでは差分のコンテンツだけを定義すればよいので
、重複を避けられる。
-----------------
そのほかにも以下のようなメリットがある。
・サイト構成（ナビゲーションなど）が一貫するので、使い勝手も向上する。
・変更する際にも共通レイアウトだけを編集すればよい。
==================================

＠レイアウトの定義
レイアウトは、それ自体Bladeテンプレートの一種に過ぎない、
ただ、他のテンプレートとは区別して、resources/views/layoutsフォルダに配置した
方が良い。
-----------------
/* resources/views/layouts/base.blade.php */
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<-- a. titleの置き場所 -->
<title>@yield('title')</title>
<!-- Bootstrapのインポート -->
<link rel="stylesheet" 
href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css">
</head>
<body>
<img src="https://wings.msn.to/image/wings.jpg" title="ロゴ">
<hr>
<!-- b. mainコンテンツの置き場所 -->
@section('main')
<p>既定のコンテンツです。</p>
@show
<hr>
<p>Copyright(c) 1998-2022, WINGS Project. All Right Reserved.</p>
</body>
</html>
-----------------
レイアウトを定義するには、@yield、@section...@showディレクティブを利用するのが
基本。
いずれも、個別のテンプレートからコンテンツを受け取る場所（セクション）を表す。
----------------------------------
双方の使い分けは、簡単なプレイスホルダーなら、@yieldで十分。
-----------------
@yieldディレクティブ
@yield(name[, default])
name：セクションの名前
default：既定のコンテンツ
-----------------
上記の例では、titleというセクションを用意している。
既定値を指定することもできるが、引数なので、ごく簡単な文字列にとどめるのが一般
的。
----------------------------------
複数行に渡るタグ文字列を既定値にするならば、@section...@showを利用すべき。
-----------------
@section...@showディレクティブ
@section(name)
  ...default...
@show
name：セクションの名前
default：既定のコンテンツ
-----------------
上記の例では、mainというセクションを用意。
@sectionの閉じは、（@endsectionではなく）@showであることに注意。
==================================

＠個別テンプレートの準備
準備したレイアウトは、それ単体では枠組みに過ぎないので、不足したコンテンツをは
め込んでいく。
-----------------
/* app/Http/Controllers/ViewController.php */
public function master()
{
  return view('view.master', [
    'msg'=>'こんにちは、世界！',
  ]);
}
-----------------
/* resources/views/layout/master.blade.php */
<!-- a. 利用する共通冷雨との宣言-->
@extends('layouts.base')
<!-- b. titleセクションのコンテンツ -->
@section('title', '共通レイアウトの基本')
<!-- c. mainセクションコンテンツ -->
@secion('main')
<p>{{ $msg }}</p>
@endssction
-----------------
まず@extendsディレクトリで、現在のページに適用すべき共通レイアウトを宣言する。
引数pathの表記は、viewメソッドと同じ。
拡張子は取り除き、/は.で表す。
-----------------
@extendsディレクティブ
@extends(path)
path：共通レイアウトのパス
-----------------
あとは、共通レイアウトに対して、@sectionディレクティブで、個別にコンテンツをは
め込んでいく。
ただし、個別テンプレート側の@sectionには、用途に応じて、構文も複数存在する。
-----------------
まず,bのパターン。
セクションに対して、簡単な文字列を渡すのに利用する。
-----------------
@sectionディレクティブ
@section(name, value)
name：セクションの名前
value：任意の文字列
-----------------
nameは、共通テンプレートの@section/@yeildで指定した名前。
これで対応するセクションに指定された値（value）が埋め込まれる。
-----------------
埋め込むべき文字列が複数行に及びものは、c.のようにブロック構文で表す。
-----------------
@sectionディレクティブ
@section(name)
...contents...
@endsection
name：セクションの名前
contents：任意の文字列
-----------------
この場合、@sectionの閉じは@endsection。
また、ブロック構文では、@parentディレクティブで、共通レイアウト側のコンテンツ
を埋め込むことも可能。
-----------------
@sectoin('main')
  @parent
  <p>{{ $msg }}</p>
@endsection
==================================

4.4 コンポーネント

＠コンポーネントとは
コンポーネントとは、Bladeテンプレートで利用できる再利用可能なUI部品。
ビューの再利用という意味ではレイアウトに似ているが、レイアウトがサイト共通の枠
組み（ヘッダ／フッタなど）を定義する仕組みであるとすれば、コンポーネントは、（
サイト共通ではないにしても）複数のページで共有するような、より小粒な部品を切り
出すための仕組み。
-----------------
以下は、サイト内でアラートボックスを表示するためのMyAlertコンポーネントを定義
し利用する例。
MyAlertコンポーネントは、以下のパラメタを受け取れる者とする。
・type：アラートの種類（success、danger、warning、infoなど）
・alertTitle：アラートのタイトル
==================================

＠コンポーネントの利用
MyAlertコンポーネントを呼び出す側のコード。
-----------------
/* app/Http/Controllers/ViewController.php */
public function comp()
{
  $data = [
    'title'=>'こんにちは、世界！',
  ];
  return view('view.comp', $data);
}
-----------------
/* resources/views/view/comp.blade.php */
@extends('layouts.base')
@section('title', '共通レイアウトの基本')
@section('main')
<x-my-alert type="success" :alewrt-title="$title">
コンポーネントは普通のビューと同じように.blade.phpファイルで定義できます！
</x-myh-alert>
@endsection
----------------------------------
a.タグ形式で呼び出す
コンポーネントは、HTMLのようなタグの形式で呼び出させる。
が、タグの名前は若干変化する。
元の名前をケバブケース形式（すべての単語を小文字にし、区切りをハイフンで繋げる
形式）に変換し、接頭辞として「x-」を付与する。
-----------------
この例であれば、MyAlertなので、my-alert、これに接頭辞をつけてx-my-alertがタグ
名となる。
----------------------------------
b.パラメタは属性として渡す
コンポーネントでは、パラメタも属性として渡す。
注意する点は以下の通り。
まず、名前はケバブケース形式に変換する。
alertTitleは、alert-titleに変化する。
また、属性値にビュー変数を渡す場合、属性名の頭にコロン:を付与する。
この例であれば、alert-title属性にビュー変数titleを渡している。
コロンなしの場合、属性値は単なる文字列とみなされる。
----------------------------------
c.タグは以下のテキストも指定できる
明示的に用意されたパラメタだけでなく、タグは以下のテキストも指定できる。
一般的には、属性には簡単な値を、配下のテキストには複数行に及ぶような、より複雑
な値を指定する。
==================================

＠コンポーネントの定義
コンポーネントは、大雑把にコンポーネントクラスと、テンプレートから構成される。
コンポーネントクラスとは、コンポーネントで利用できる属性（パラメタ）／メソッド
を準備するためのクラス。
一般的なビューに対するコントローラクラスに相当するものと言い換えてもよい。
----------------------------------
[1]コンポーネント関連のファイルを生成する
>php artisan make:component MyAlert
...
以下のファイルが生成される。
・/app/View/Coponents/MyAlert.php（コンポーネントクラス）
・/resources/views/components/my-alert.blade.php（テンプレート）
----------------------------------
[2]コンポーネントクラスを編集する
/* app/Views/Compoonents/MyAlert.php */
<?php
namespace App\View\Components;
use Iluminate\View\Component;

class MyAlert extends Component
{
  // a. コンポーネントのパラメタ
  public string $type;
  public string $alertTitle;
  
  // b. パラメタを初期化
  public function __construct(string $tpe, string $alertTitle)
  {
    $this->type = $type;
    $this->alertTitle = $alertTitle;
  }
  
  // c. ビューの呼び出し
  public function render()
  {
    return view('components.my-alert');
  }
}
-----------------
a. b. コンポーネントのパラメタを準備
コンポーネントが受け取るべき属性（パラメタ）をpublicプロパティとして準備し、コ
ンストラクタから初期化するのが基本ん。
タグは以下のテキストは別枠なので、明示的な宣言は不要。
-----------------
c.描画コードを準備
描画のための処理を記述するのがrenderメソッド。
コントローラーのアクションメソッドに相当するメソッド。
viewメソッドでテンプレートを呼び出すコードもこれまでと同じ。
----------------------------------
[3]テンプレートと編集する
/* /resources/views/componentsw/my-alert.blade.php */
<div class="alert alert{{ $type}}">
  <h4 class="alert-heading">{{ $alert-title }}</h4>
  <p>{{ $slot }}</p>
</div>
-----------------
ビュー変数と同じ要領で、テンプレートからはコンポーネントのプロパティにアクセス
できる。
$slotは、タグ本体から渡されたテキストを表す。
$slotは暗黙的に準備される変数なので、事前の宣言なく利用できる。
このようなタグ本体経由での値受け渡しの仕組みをスロットという）。
----------------------------------
＊複数スロットへの対応
スロットは複数渡すこともできる。
<x-my-alert type="success" :alert-title="$title">
コンポーネントは普通のビューと同じように.blade.phpファイルで定義できる！
<x-slot:footer>
フッターテキスト
</x-slot>
-----------------
<x-slog:名前>形式で、名前付きのスロットを定義する。
名前付きスロットは、他の属性値と同じく、{{ $footer }}のようにアクセスできる（
コンポーネントでの宣言っも不要。
明示的に<x-slot>で括られなかったテキストは、これまでと同じく$slotでアクセスで
きる。
==================================

＠動的コンポーネント
Laravel標準のx-dyanmic-componentコンポーネントをりようすることで、表示すべきコ
ンポーネントを動的に切り換えることもできる。
-----------------
/* /app/Http/Controlers/ViewController.php */
public function comp()
{
  $data = [
    'title'=>'こんにちは、世界！',
    'comp'=>'my-alert'
  ];
  return view('view.comp', $data);
-----------------
/* /resources/views/view/comp.bladde.php */
<x-dyanamic-component :component="$comp" type="success" :alert-title="$title">
コンポーネントは普通のビューと同じように、.blade.phpファイルで定義できます！
</x-dynamic-compnent>
-----------------
この例では、ビュー変数$compで表示すべきコンポーネントを決め打ちしているので、
あえて動的コンポーネントをりようする意味はない。
実際のアプリでは、実行時の条件に応じて、$compの値を変更することになる。
==================================

4.5 サブビュー

＠サブビュー
部分的なビューを表すという意味で、サブビューはコンポーネントによく似た機能。
ただし、単なるテンプレートの断片化であって（コンポーネントクラスに相当するしく
みはない）。
できることは限定される。
サブビューは簡単なビューの再利用と割り切り、より高度な利用にはコンポーネントを
利用することが推奨される。

＠サブビューの基本
先に定義したmy-alert.blade.phpをサブビューとして引用するには、@includeディレク
ティブを利用する。
-----------------
/* /resources/views/view/comp.blade.php */
@include('components.my-alert', [
  'type'=>'success',
  'alertTitle'=>'はじめてのコンポーネント',
  'slot'=>'コンポーネントは普通のビューと同じように.blade.phpファイルで定義できます！',
])
==================================

＠コレクションビュー
コレクションビューは、いわゆるコレクション（配列）に対して適用できる、特別なサ
ブビュー。
配列の各要素にサブビューを適用しながら順に出力するようなコードも、コレクション
ビューを利用することで、簡単に実装できる。
----------------------------------
[1]コレクションビューを準備する
まずは配列の要素ごとに適用する部分ビューを準備する。
保存先を/views/subviewsとする。
-----------------
/* /resources/views/subviews/book.blade.php */
<tr>
  <td>{{ $record->title }}</td>
  <td>{{ $record->price }}円</td>
  <td>{{ $record->publisher }}</td>
  <td>{{ $record->published }}</td>
</tr>
-----------------
コレクションビューで利用するテンプレートには、一項目ごとの（@foreachの配下で表
していたような）ビューを定義する。
仮引数（ここでは$record）は何でも構わない。
（後で呼び出し側で指定する。）
----------------------------------
[2]空ビューを準備する
配列が空だった場合のテンプレートも用意しておく。

-----------------
/* /resources/views/subviews/empty.blade.php */
<p>書籍情報はありません。</p>
----------------------------------
[3]コレクションビューを呼び出す
定義したコレクションビューを呼び出しているのが、以下のメインテンプレート。
-----------------
/* /resources/views/hello/list.blade.php */
@extends('layouts.base')
@section('title', '共通レイアウトの基本')
@section('main')
<table class="table">
<tr>
  <th>書名</th>
  <th>価格</th>
  <th>出版社</th>
  <th>刊行日</th>
</tr>
@each('subviews.book', $records, 'record', 'subviews.empty')
</table>
@endsection
-----------------
コレクションビューを呼び出すのは、@eachディレクティブ。
-----------------
@eachディレクティブ
@each(path, data, var, emp_path)
path：コレクションビューのパスワード
data：繰り返しに利用する配列
var：仮変数（コレクションビューでの参照用）
emp_path：配列dataが空の場合に表示するビュー（省略可）
-----------------
@eachは、@foreach+@include(+@if)の組み合わせでも代用できるが、冗長。
==================================

Part5：ルーティング

＠ルーティングの基
ルーティングの基本的なしくみは、リクエストURLとコントローラー（アクション）
の紐づけ。
----------------------------------
Route::getがルート定義の基本、ただしくは「HTTP GET経由でのリクエストを処理」す
るのが、getメソッドの役割。
HTTP POST経由でのリクエストを処理するならば、postメソッドを利用する。
-----------------
Route::post('/route/post', [RouteController::class, 'post']);
-----------------
その他、HTTPメソッドに対応して、以下のメソッドが用意されている。
-----------------
・put
・patch
・delete
・options
-----------------
複数のHTTPメソッドにまとめて対応するならば、matchメソッドもある。
例えば、HTTP GET/POSTに対応するルートを定義するなら、以下のようにする。
-----------------
Route::match(['get', 'post'], '/route/match', [RouteController::class, 'match']);
-----------------
HTTPメソッドを特定せず、すべてのHTTPメソッドに無条件に対応するなら、anyメソッ
ドを利用してもよい。
-----------------
Route::any('/route/any', [RouteController::class, 'any']);
----------------------------------
＊ルート定義の確認
ルート定義が増えてくると、見通しが悪くなる。
そのような場合には、以下のようなコマンドを使うことで、アルファベット順に見やす
い形で確認できる。
-----------------
> php artisan route:list
....
==================================

5.2 ルートパラメーター

＠ルートパラメーターとは
例えば「/blog/20220625」「/book/978-4-7981-5112-0/」のようなパスで、「20220625
」「978-4-7981-5112-0」のような値を、コントローラー（アクション）に引渡すこと
ができる。
パラメーター値をパスの一部として表現できるため、ルータ経由の値の引き渡しでよく
利用される。
このようなパラメータをルートパラメタという。
==================================

＠ルートパラメーターの基本
[1]ルーティング情報を定義する
-----------------
/* /routes/web.php */
Route::get('/route/param/{id}', [RouteController::class, 'paramU']);
-----------------
{名前}の部分がパラメタのプレースホルダーで、{名前}の部分に「/route/param/108」
のように、自由に値を埋め込むことができる。
名前はアルファベット+アンダースコアで命名する（ハイフンは不可）。
-----------------
以下のように複数のパラメーターを設定してもよい。
-----------------
Route::get('/blog/{year}/{month}/{day}', [...]);
----------------------------------
[2]ルートパラメーターを受け取るアクションを準備する
/* app/Http/Controllers/RouteController.php */
public function param(int $id)
{
  return 'id値：' . $id;
}
-----------------
アクションメソッドにルートパラメタを受け取るための引数を用意するだけ。
これによって、Laravelが自動的に対応する値を引数に割り当ててくれる。
複数ある場合、それに応じて、引数も列挙する。
<<<<<<< HEAD
==================================

＠任意のルートパラメーター
ルートパラメータは既定で必須の扱いとなる。
よって「.../route/param」はマッチしない。
任意パラメタを指定したい場合、パラメーター名の後に「?」を付与する。
-----------------
Route::get('/route/param/{id?}', [RouteController::class, 'param']);
-----------------
これにより{id}は任意となるので、「.../route/param/」もマッチする。
-----------------
パラメーターを任意とした場合、アクションの側で、既定値を明示しておかなくてはな
らない。
でないと、「Too few arguments to function...」のようなエラーとなる。
-----------------
public function param(int $id=1)
{
  ...
}
-----------------
この場合、「.../route/param」のid値は1となる。
==================================

＠ルートパラメーターの制約
=======
----------------------------------
一般的には、この値をキーにデータベースなどへの問合せを行うことになる。
==================================

＠任意のルートパラメータ
ルートパラメーターは、既定では必須の扱いとなる。
よって上記の例：では、「～/route/param」はマッチしない。
任意パラメタを指定したいなら、パラメーター名の末尾に「?」をつける。
-----------------
/* /routes/web.php */
Route::get('/route/param/{id?}', [RouteController::class, 'param']);
-----------------
これにより{id}パラメタは任意扱いとなるので、「～/route/param」がマッチするよう
になる。
-----------------
なお、パラメーターを任意とした場合には、これを受け取るアクション（引数）の側で
、規定値を明示しておかなければ、エラーとなる。
-----------------
public function param(int $id = 1)
-----------------
この場合、「～/route/param」での結果は、「id値：1」。
==================================

＠ルートパラメーターの制約
受け取るべきルートパラメーターの値があらかじめ想定できている場合、正規表現で値
の形式を制限することもできる。
以下は、{id}パラメーターが2～3桁の数値であることを宣言している。
-----------------
/* /routes/web.php */
Route::get('/route/pram/{id?}', [RouteController::class, 'param'])
->where(['id'=>'[0-9]{2,3}']);
-----------------
正規表現の制約は、ルート定義の後方、whereメソッドで宣言する。
引数は、「パラメーター名=>正規表現」形式の連想配列。
よって、パラメーターが複数になった場合も、配列要素を列挙するだけ。
----------------------------------
＊ヘルパーメソッド
よく利用される正規表現についてはヘルパーメソッドが用意されている。
whereNumber  整数
whereAlpha  アルファベット
whereAlphaNumeric  アルファベット、または数値
whereUuid  ユニークな整数
-----------------
例えばid値が整数であることを確認したいならば、以下のようにする。
-----------------
Route::get('/route/param/{id?}', [RouteController::class, 'param'])
=>whereNumber('id');
-----------------
whereXxxxメソッドには、文字列のほか、対象となるパラメタを配列で複数列記するこ
ともできる。
----------------------------------
＊グローバル制約
ルートをまたがって、特定のパラメーターに対して制約を付与したいなら、/app/provi
ders/RouteServiceProvider.phpに対して、以下のコードを追加する。
これによって、すべての{id}パラメーターに対して、正規表現による制約が付与される
。
-----------------
public function boot()
{
  Route::pattern('id', '[0-9]{2,3}');
  ...
}
==================================

＠可変長パラメーター
正規表現を用いることで、可変長パラメーターも表現できる。
可変長パラメーターとは、例えば
「～/search/laravel/php/framework」であれば「～/search/」以降の「laravel/php/f
ramework」をまとめてひとつの変数で受け取れるようなパラメーターのこと。
任意個数のパラメーターを扱いたい場合に便利。
-----------------
/* routes/web.php */
Route::get('/route/search/{keywd?}', [RouteController::class, 'search'])
->where('keywd', '.*');
-----------------
「.*」で、「/」含めた任意の文字が0文字以上、という意味になる。
これにより、「～/route/search/laravel/php/framework」のようなパスに対し、keywd
パラメーターは、「laravel/php/framework」のようなスラッシュ区切りの文字列とな
る。
（よって、利用する側はスラッシュで値を分割してから利用することになるだろう。）
==================================

5.3 特別なルート定義

＠ルートに共通の接頭辞を付与する
たとえば会員向けのページに対して「/members」のような共通のパス接頭辞を付与した
い場合がある。
その場合、prefixメソッドを利用することで、共通の接頭辞をまとめて宣言できる。
以下は、/members/info, /members/articleルートを定義する例。
-----------------
/* routes/web.php */
Route::prefix('/members')->group(function() {
  Route::get('/info', [RouteController::class, 'info']);
  Route::get('/article', [RouteController::class, ''article']);
  ...
});
-----------------
このように、ルート定義を意味的な役割の単位に束ねるしくみをルートグループという
。
==================================

＠同一コントローラへのルート情報を束ねる
controllerメソッドを利用することで、同じコントローラーのルート定義を一つのブロ
ックで束ねられるようになる。
-----------------
一般に、同じコントローラーには関連する処理が含まれているはずなので、ルート定義
も一ヶ所にまとめることで、ルート定義の見通しが改善する。
-----------------
/* routes/web.php */
use \App\Http\Controllers\HelloController;
...
Route::controller(HelloController::class)->group(function() {
  Route::get('/hello', 'index');
  Route::get('/hello/view', 'view');
  Route::get('/hello/list', 'list');
});
-----------------
コントローラーはすでに特定できているので、個々のgetメソッド（第2引数）ではアク
ション名だけを記述すればよい。
==================================

＠名前空間付きのコントローラー
ルートグループを利用することで、名前空間付きのコントローラーを束ねることもでき
る。名前空間付きとは、既定の名前空間（App\Http\Controllers）配下のサブ名前空間
に属するコントローラーのこと。
ある程度の規模のアプリであれば、（App\Http\Controllers名前空間だけでなく）複数
の名前空間に分けることで、ファイルの見通しもよくなる。
-----------------
このような名前空間付きのコントローラーにルートを割り当てるには、namespaceメソ
ッドを利用する。
以下は、App\Http\Controllers\Man名前空間に属するRouteControllerコントローラー
をルート定義する例：。
-----------------
/* routes/web.php */
Route::namespace('Main')->group(function() {
  Route::get('/route/ns', [RouteController::class, 'ns');
});
==================================

＠アクションの省略
アクションによる処理を必要としない（＝指定のビューを表示するだけ）の場合には、
viewメソッドでビューを直接指定できる。
-----------------
/* routes/web.php */
Route::view('/route', 'route.view', ['name'=>'Laravel']);
-----------------
これで「/routeに対してはroute/view.blade.phpを返す」という意味になる。
第3引数には、ビュー変数を渡すこともできるので、簡単な値の引き渡しであれば、vie
wメソッドで十分賄える。
==================================

＠Enum型によるパラメーターの制限
Laravel 9.xでは、ルートパラメーターの値をEnum型（列挙体）に割り当てられる用に
なった。
以下はカテゴリ情報を定義するCategory列挙体と、これに紐づいたルート情報の例：。
※一般的には列挙体とコントローラークラスは、別ファイルに切り出す。
-----------------
/* routes/web.php */
Route::get('/route/enum_param/{category}', [RouteController::class, 'enum_param');
kose 

/* App/Http/Controllers/RouteController.php */
class RouteController extends Controller
{
  ...
  //a. ルートパラメーターを列挙体に割り当て
  public function enum_param(Category $category)
  {
    return $category->value;
  }
}
// カテゴリ情報を表す列挙体
emun Category: string
{
  case Langage = 'lang',
  case Framework = 'fw',
  case Tools = 'tools',
}
-----------------
ルートパラメーターに列挙体を割り当てるには、引数型として列挙体を指定するだけ。
これでパラメーター値が指定型にキャストされ、キャストできない場合には、404 Not 
Foundエラーを返すようになる。
==================================

＠リダイレクト
特定のパスを別のルートにリダイレクトするには、redirectメソッドを利用する。
例えば以下は「/hoge」を「/」に振り分ける例。
-----------------
/* routes/web.php */
Route::redirect('/hoge', '/');
-----------------
redirectメソッドは既定で「302 Found」（一時的な移動）を返す。
恒久的なページの移動を表すなら、ステータスコードを指定する。
-----------------
Route::redirect('/hoge', '/', 301);
-----------------
適切なステータスコードの指定は、検索エンジンに正しいページを認識してもらう、と
いう意味でも有効。
==================================

＠リソースルート
resourceメソッドを利用することで、典型的なCRUD（Create-Read-Update-Delete）ア
クションをまとめてルート定義できる。
-----------------
/* routes/web.php */
Route::resource('/articles', 'ArticleController');
-----------------
resource宣言によって、以下のようなルートが定義される。
-----------------
メソッド    パス                      アクション名            概要
GET         /articles                 index                   一覧の表示
GET         /articles/{article}       show                    詳細の表示
GET         /articles/create          create                  登録フォーム
POST        /articles                 store                   登録処理
GET         /articles/{article}/edit  edit                    編集フォーム
PUT/PATCH   /articles/{article}       update                  更新処理
DELETE      /articles/{article}       destory                 削除処理
-----------------
特定のルート（アクション）を無効化するなら、以下のようにexceptメソッドを利用す
る。
以下は、edit/updateメソッドを除外する例：。
-----------------
Route::resource('/articles', 'ArticleController')
->except(['edit', 'update']);
-----------------
resourcesメソッドによって、複数のリソースルートをまとめて定義することも可能。
引数の形式は「パス=>コントローラー」。
-----------------
Route::resources([
  '/articles'=>'ArticleController',
  ...
]);
----------------------------------
＊リソースコントローラー
リソースルートに対応するコントローラーは、以下のようなコマンドで自動生成できる
。
-----------------
> php artisan make:controller ArticleController --resource --model=Article
-----------------
標準的なコントローラー作成コマンドにresource/modelオプションを指定するだけ。
modelオプションは、アクションの引数に対応するモデルを割り当てることを意味する
。
==================================
